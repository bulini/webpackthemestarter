/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!**************************************!*\
  !*** ./node_modules/slick/parser.js ***!
  \**************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\nSlick Parser\r\n - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)\r\n*/\n\n// Notable changes from Slick.Parser 1.0.x\n\n// The parser now uses 2 classes: Expressions and Expression\n// `new Expressions` produces an array-like object containing a list of Expression objects\n// - Expressions::toString() produces a cleaned up expressions string\n// `new Expression` produces an array-like object\n// - Expression::toString() produces a cleaned up expression string\n// The only exposed method is parse, which produces a (cached) `new Expressions` instance\n// parsed.raw is no longer present, use .toString()\n// parsed.expression is now useless, just use the indices\n// parsed.reverse() has been removed for now, due to its apparent uselessness\n// Other changes in the Expressions object:\n// - classNames are now unique, and save both escaped and unescaped values\n// - attributes now save both escaped and unescaped values\n// - pseudos now save both escaped and unescaped values\n\nvar escapeRe = /([-.*+?^${}()|[\\]\\/\\\\])/g,\n    unescapeRe = /\\\\/g;\n\nvar escape = function (string) {\n    // XRegExp v2.0.0-beta-3\n    // Â« https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js\n    return (string + \"\").replace(escapeRe, '\\\\$1');\n};\n\nvar unescape = function (string) {\n    return (string + \"\").replace(unescapeRe, '');\n};\n\nvar slickRe = RegExp(\n/*\r\n#!/usr/bin/env ruby\r\nputs \"\\t\\t\" + DATA.read.gsub(/\\(\\?x\\)|\\s+#.*$|\\s+|\\\\$|\\\\n/,'')\r\n__END__\r\n    \"(?x)^(?:\\\r\n      \\\\s* ( , ) \\\\s*               # Separator          \\n\\\r\n    | \\\\s* ( <combinator>+ ) \\\\s*   # Combinator         \\n\\\r\n    |      ( \\\\s+ )                 # CombinatorChildren \\n\\\r\n    |      ( <unicode>+ | \\\\* )     # Tag                \\n\\\r\n    | \\\\#  ( <unicode>+       )     # ID                 \\n\\\r\n    | \\\\.  ( <unicode>+       )     # ClassName          \\n\\\r\n    |                               # Attribute          \\n\\\r\n    \\\\[  \\\r\n        \\\\s* (<unicode1>+)  (?:  \\\r\n            \\\\s* ([*^$!~|]?=)  (?:  \\\r\n                \\\\s* (?:\\\r\n                    ([\\\"']?)(.*?)\\\\9 \\\r\n                )\\\r\n            )  \\\r\n        )?  \\\\s*  \\\r\n    \\\\](?!\\\\]) \\n\\\r\n    |   :+ ( <unicode>+ )(?:\\\r\n    \\\\( (?:\\\r\n        (?:([\\\"'])([^\\\\12]*)\\\\12)|((?:\\\\([^)]+\\\\)|[^()]*)+)\\\r\n    ) \\\\)\\\r\n    )?\\\r\n    )\"\r\n*/\n\"^(?:\\\\s*(,)\\\\s*|\\\\s*(<combinator>+)\\\\s*|(\\\\s+)|(<unicode>+|\\\\*)|\\\\#(<unicode>+)|\\\\.(<unicode>+)|\\\\[\\\\s*(<unicode1>+)(?:\\\\s*([*^$!~|]?=)(?:\\\\s*(?:([\\\"']?)(.*?)\\\\9)))?\\\\s*\\\\](?!\\\\])|(:+)(<unicode>+)(?:\\\\((?:(?:([\\\"'])([^\\\\13]*)\\\\13)|((?:\\\\([^)]+\\\\)|[^()]*)+))\\\\))?)\".replace(/<combinator>/, '[' + escape(\">+~`!@$%^&={}\\\\;</\") + ']').replace(/<unicode>/g, '(?:[\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])').replace(/<unicode1>/g, '(?:[:\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])'));\n\n// Part\n\nvar Part = function Part(combinator) {\n    this.combinator = combinator || \" \";\n    this.tag = \"*\";\n};\n\nPart.prototype.toString = function () {\n\n    if (!this.raw) {\n\n        var xpr = \"\",\n            k,\n            part;\n\n        xpr += this.tag || \"*\";\n        if (this.id) xpr += \"#\" + this.id;\n        if (this.classes) xpr += \".\" + this.classList.join(\".\");\n        if (this.attributes) for (k = 0; part = this.attributes[k++];) {\n            xpr += \"[\" + part.name + (part.operator ? part.operator + '\"' + part.value + '\"' : '') + \"]\";\n        }\n        if (this.pseudos) for (k = 0; part = this.pseudos[k++];) {\n            xpr += \":\" + part.name;\n            if (part.value) xpr += \"(\" + part.value + \")\";\n        }\n\n        this.raw = xpr;\n    }\n\n    return this.raw;\n};\n\n// Expression\n\nvar Expression = function Expression() {\n    this.length = 0;\n};\n\nExpression.prototype.toString = function () {\n\n    if (!this.raw) {\n\n        var xpr = \"\";\n\n        for (var j = 0, bit; bit = this[j++];) {\n            if (j !== 1) xpr += \" \";\n            if (bit.combinator !== \" \") xpr += bit.combinator + \" \";\n            xpr += bit;\n        }\n\n        this.raw = xpr;\n    }\n\n    return this.raw;\n};\n\nvar replacer = function (rawMatch, separator, combinator, combinatorChildren, tagName, id, className, attributeKey, attributeOperator, attributeQuote, attributeValue, pseudoMarker, pseudoClass, pseudoQuote, pseudoClassQuotedValue, pseudoClassValue) {\n\n    var expression, current;\n\n    if (separator || !this.length) {\n        expression = this[this.length++] = new Expression();\n        if (separator) return '';\n    }\n\n    if (!expression) expression = this[this.length - 1];\n\n    if (combinator || combinatorChildren || !expression.length) {\n        current = expression[expression.length++] = new Part(combinator);\n    }\n\n    if (!current) current = expression[expression.length - 1];\n\n    if (tagName) {\n\n        current.tag = unescape(tagName);\n    } else if (id) {\n\n        current.id = unescape(id);\n    } else if (className) {\n\n        var unescaped = unescape(className);\n\n        var classes = current.classes || (current.classes = {});\n        if (!classes[unescaped]) {\n            classes[unescaped] = escape(className);\n            var classList = current.classList || (current.classList = []);\n            classList.push(unescaped);\n            classList.sort();\n        }\n    } else if (pseudoClass) {\n\n        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;(current.pseudos || (current.pseudos = [])).push({\n            type: pseudoMarker.length == 1 ? 'class' : 'element',\n            name: unescape(pseudoClass),\n            escapedName: escape(pseudoClass),\n            value: pseudoClassValue ? unescape(pseudoClassValue) : null,\n            escapedValue: pseudoClassValue ? escape(pseudoClassValue) : null\n        });\n    } else if (attributeKey) {\n\n        attributeValue = attributeValue ? escape(attributeValue) : null;(current.attributes || (current.attributes = [])).push({\n            operator: attributeOperator,\n            name: unescape(attributeKey),\n            escapedName: escape(attributeKey),\n            value: attributeValue ? unescape(attributeValue) : null,\n            escapedValue: attributeValue ? escape(attributeValue) : null\n        });\n    }\n\n    return '';\n};\n\n// Expressions\n\nvar Expressions = function Expressions(expression) {\n    this.length = 0;\n\n    var self = this;\n\n    var original = expression,\n        replaced;\n\n    while (expression) {\n        replaced = expression.replace(slickRe, function () {\n            return replacer.apply(self, arguments);\n        });\n        if (replaced === expression) throw new Error(original + ' is an invalid expression');\n        expression = replaced;\n    }\n};\n\nExpressions.prototype.toString = function () {\n    if (!this.raw) {\n        var expressions = [];\n        for (var i = 0, expression; expression = this[i++];) expressions.push(expression);\n        this.raw = expressions.join(\", \");\n    }\n\n    return this.raw;\n};\n\nvar cache = {};\n\nvar parse = function (expression) {\n    if (expression == null) return null;\n    expression = ('' + expression).replace(/^\\s+|\\s+$/g, '');\n    return cache[expression] || (cache[expression] = new Expressions(expression));\n};\n\nmodule.exports = parse;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvc2xpY2svcGFyc2VyLmpzPzMwZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuU2xpY2sgUGFyc2VyXHJcbiAtIG9yaWdpbmFsbHkgY3JlYXRlZCBieSB0aGUgYWxtaWdodHkgVGhvbWFzIEF5bG90dCA8QHN1YnRsZWdyYWRpZW50PiAoaHR0cDovL3N1YnRsZWdyYWRpZW50LmNvbSlcclxuKi9cInVzZSBzdHJpY3RcIlxyXG5cclxuLy8gTm90YWJsZSBjaGFuZ2VzIGZyb20gU2xpY2suUGFyc2VyIDEuMC54XHJcblxyXG4vLyBUaGUgcGFyc2VyIG5vdyB1c2VzIDIgY2xhc3NlczogRXhwcmVzc2lvbnMgYW5kIEV4cHJlc3Npb25cclxuLy8gYG5ldyBFeHByZXNzaW9uc2AgcHJvZHVjZXMgYW4gYXJyYXktbGlrZSBvYmplY3QgY29udGFpbmluZyBhIGxpc3Qgb2YgRXhwcmVzc2lvbiBvYmplY3RzXHJcbi8vIC0gRXhwcmVzc2lvbnM6OnRvU3RyaW5nKCkgcHJvZHVjZXMgYSBjbGVhbmVkIHVwIGV4cHJlc3Npb25zIHN0cmluZ1xyXG4vLyBgbmV3IEV4cHJlc3Npb25gIHByb2R1Y2VzIGFuIGFycmF5LWxpa2Ugb2JqZWN0XHJcbi8vIC0gRXhwcmVzc2lvbjo6dG9TdHJpbmcoKSBwcm9kdWNlcyBhIGNsZWFuZWQgdXAgZXhwcmVzc2lvbiBzdHJpbmdcclxuLy8gVGhlIG9ubHkgZXhwb3NlZCBtZXRob2QgaXMgcGFyc2UsIHdoaWNoIHByb2R1Y2VzIGEgKGNhY2hlZCkgYG5ldyBFeHByZXNzaW9uc2AgaW5zdGFuY2VcclxuLy8gcGFyc2VkLnJhdyBpcyBubyBsb25nZXIgcHJlc2VudCwgdXNlIC50b1N0cmluZygpXHJcbi8vIHBhcnNlZC5leHByZXNzaW9uIGlzIG5vdyB1c2VsZXNzLCBqdXN0IHVzZSB0aGUgaW5kaWNlc1xyXG4vLyBwYXJzZWQucmV2ZXJzZSgpIGhhcyBiZWVuIHJlbW92ZWQgZm9yIG5vdywgZHVlIHRvIGl0cyBhcHBhcmVudCB1c2VsZXNzbmVzc1xyXG4vLyBPdGhlciBjaGFuZ2VzIGluIHRoZSBFeHByZXNzaW9ucyBvYmplY3Q6XHJcbi8vIC0gY2xhc3NOYW1lcyBhcmUgbm93IHVuaXF1ZSwgYW5kIHNhdmUgYm90aCBlc2NhcGVkIGFuZCB1bmVzY2FwZWQgdmFsdWVzXHJcbi8vIC0gYXR0cmlidXRlcyBub3cgc2F2ZSBib3RoIGVzY2FwZWQgYW5kIHVuZXNjYXBlZCB2YWx1ZXNcclxuLy8gLSBwc2V1ZG9zIG5vdyBzYXZlIGJvdGggZXNjYXBlZCBhbmQgdW5lc2NhcGVkIHZhbHVlc1xyXG5cclxudmFyIGVzY2FwZVJlICAgPSAvKFstLiorP14ke30oKXxbXFxdXFwvXFxcXF0pL2csXHJcbiAgICB1bmVzY2FwZVJlID0gL1xcXFwvZ1xyXG5cclxudmFyIGVzY2FwZSA9IGZ1bmN0aW9uKHN0cmluZyl7XHJcbiAgICAvLyBYUmVnRXhwIHYyLjAuMC1iZXRhLTNcclxuICAgIC8vIMKrIGh0dHBzOi8vZ2l0aHViLmNvbS9zbGV2aXRoYW4vWFJlZ0V4cC9ibG9iL21hc3Rlci9zcmMveHJlZ2V4cC5qc1xyXG4gICAgcmV0dXJuIChzdHJpbmcgKyBcIlwiKS5yZXBsYWNlKGVzY2FwZVJlLCAnXFxcXCQxJylcclxufVxyXG5cclxudmFyIHVuZXNjYXBlID0gZnVuY3Rpb24oc3RyaW5nKXtcclxuICAgIHJldHVybiAoc3RyaW5nICsgXCJcIikucmVwbGFjZSh1bmVzY2FwZVJlLCAnJylcclxufVxyXG5cclxudmFyIHNsaWNrUmUgPSBSZWdFeHAoXHJcbi8qXHJcbiMhL3Vzci9iaW4vZW52IHJ1YnlcclxucHV0cyBcIlxcdFxcdFwiICsgREFUQS5yZWFkLmdzdWIoL1xcKFxcP3hcXCl8XFxzKyMuKiR8XFxzK3xcXFxcJHxcXFxcbi8sJycpXHJcbl9fRU5EX19cclxuICAgIFwiKD94KV4oPzpcXFxyXG4gICAgICBcXFxccyogKCAsICkgXFxcXHMqICAgICAgICAgICAgICAgIyBTZXBhcmF0b3IgICAgICAgICAgXFxuXFxcclxuICAgIHwgXFxcXHMqICggPGNvbWJpbmF0b3I+KyApIFxcXFxzKiAgICMgQ29tYmluYXRvciAgICAgICAgIFxcblxcXHJcbiAgICB8ICAgICAgKCBcXFxccysgKSAgICAgICAgICAgICAgICAgIyBDb21iaW5hdG9yQ2hpbGRyZW4gXFxuXFxcclxuICAgIHwgICAgICAoIDx1bmljb2RlPisgfCBcXFxcKiApICAgICAjIFRhZyAgICAgICAgICAgICAgICBcXG5cXFxyXG4gICAgfCBcXFxcIyAgKCA8dW5pY29kZT4rICAgICAgICkgICAgICMgSUQgICAgICAgICAgICAgICAgIFxcblxcXHJcbiAgICB8IFxcXFwuICAoIDx1bmljb2RlPisgICAgICAgKSAgICAgIyBDbGFzc05hbWUgICAgICAgICAgXFxuXFxcclxuICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBBdHRyaWJ1dGUgICAgICAgICAgXFxuXFxcclxuICAgIFxcXFxbICBcXFxyXG4gICAgICAgIFxcXFxzKiAoPHVuaWNvZGUxPispICAoPzogIFxcXHJcbiAgICAgICAgICAgIFxcXFxzKiAoWypeJCF+fF0/PSkgICg/OiAgXFxcclxuICAgICAgICAgICAgICAgIFxcXFxzKiAoPzpcXFxyXG4gICAgICAgICAgICAgICAgICAgIChbXFxcIiddPykoLio/KVxcXFw5IFxcXHJcbiAgICAgICAgICAgICAgICApXFxcclxuICAgICAgICAgICAgKSAgXFxcclxuICAgICAgICApPyAgXFxcXHMqICBcXFxyXG4gICAgXFxcXF0oPyFcXFxcXSkgXFxuXFxcclxuICAgIHwgICA6KyAoIDx1bmljb2RlPisgKSg/OlxcXHJcbiAgICBcXFxcKCAoPzpcXFxyXG4gICAgICAgICg/OihbXFxcIiddKShbXlxcXFwxMl0qKVxcXFwxMil8KCg/OlxcXFwoW14pXStcXFxcKXxbXigpXSopKylcXFxyXG4gICAgKSBcXFxcKVxcXHJcbiAgICApP1xcXHJcbiAgICApXCJcclxuKi9cclxuXCJeKD86XFxcXHMqKCwpXFxcXHMqfFxcXFxzKig8Y29tYmluYXRvcj4rKVxcXFxzKnwoXFxcXHMrKXwoPHVuaWNvZGU+K3xcXFxcKil8XFxcXCMoPHVuaWNvZGU+Kyl8XFxcXC4oPHVuaWNvZGU+Kyl8XFxcXFtcXFxccyooPHVuaWNvZGUxPispKD86XFxcXHMqKFsqXiQhfnxdPz0pKD86XFxcXHMqKD86KFtcXFwiJ10/KSguKj8pXFxcXDkpKSk/XFxcXHMqXFxcXF0oPyFcXFxcXSl8KDorKSg8dW5pY29kZT4rKSg/OlxcXFwoKD86KD86KFtcXFwiJ10pKFteXFxcXDEzXSopXFxcXDEzKXwoKD86XFxcXChbXildK1xcXFwpfFteKCldKikrKSlcXFxcKSk/KVwiXHJcbiAgICAucmVwbGFjZSgvPGNvbWJpbmF0b3I+LywgJ1snICsgZXNjYXBlKFwiPit+YCFAJCVeJj17fVxcXFw7PC9cIikgKyAnXScpXHJcbiAgICAucmVwbGFjZSgvPHVuaWNvZGU+L2csICcoPzpbXFxcXHdcXFxcdTAwYTEtXFxcXHVGRkZGLV18XFxcXFxcXFxbXlxcXFxzMC05YS1mXSknKVxyXG4gICAgLnJlcGxhY2UoLzx1bmljb2RlMT4vZywgJyg/Ols6XFxcXHdcXFxcdTAwYTEtXFxcXHVGRkZGLV18XFxcXFxcXFxbXlxcXFxzMC05YS1mXSknKVxyXG4pXHJcblxyXG4vLyBQYXJ0XHJcblxyXG52YXIgUGFydCA9IGZ1bmN0aW9uIFBhcnQoY29tYmluYXRvcil7XHJcbiAgICB0aGlzLmNvbWJpbmF0b3IgPSBjb21iaW5hdG9yIHx8IFwiIFwiXHJcbiAgICB0aGlzLnRhZyA9IFwiKlwiXHJcbn1cclxuXHJcblBhcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcclxuXHJcbiAgICBpZiAoIXRoaXMucmF3KXtcclxuXHJcbiAgICAgICAgdmFyIHhwciA9IFwiXCIsIGssIHBhcnRcclxuXHJcbiAgICAgICAgeHByICs9IHRoaXMudGFnIHx8IFwiKlwiXHJcbiAgICAgICAgaWYgKHRoaXMuaWQpIHhwciArPSBcIiNcIiArIHRoaXMuaWRcclxuICAgICAgICBpZiAodGhpcy5jbGFzc2VzKSB4cHIgKz0gXCIuXCIgKyB0aGlzLmNsYXNzTGlzdC5qb2luKFwiLlwiKVxyXG4gICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMpIGZvciAoayA9IDA7IHBhcnQgPSB0aGlzLmF0dHJpYnV0ZXNbaysrXTspe1xyXG4gICAgICAgICAgICB4cHIgKz0gXCJbXCIgKyBwYXJ0Lm5hbWUgKyAocGFydC5vcGVyYXRvciA/IHBhcnQub3BlcmF0b3IgKyAnXCInICsgcGFydC52YWx1ZSArICdcIicgOiAnJykgKyBcIl1cIlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wc2V1ZG9zKSBmb3IgKGsgPSAwOyBwYXJ0ID0gdGhpcy5wc2V1ZG9zW2srK107KXtcclxuICAgICAgICAgICAgeHByICs9IFwiOlwiICsgcGFydC5uYW1lXHJcbiAgICAgICAgICAgIGlmIChwYXJ0LnZhbHVlKSB4cHIgKz0gXCIoXCIgKyBwYXJ0LnZhbHVlICsgXCIpXCJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmF3ID0geHByXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnJhd1xyXG59XHJcblxyXG4vLyBFeHByZXNzaW9uXHJcblxyXG52YXIgRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIEV4cHJlc3Npb24oKXtcclxuICAgIHRoaXMubGVuZ3RoID0gMFxyXG59XHJcblxyXG5FeHByZXNzaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgaWYgKCF0aGlzLnJhdyl7XHJcblxyXG4gICAgICAgIHZhciB4cHIgPSBcIlwiXHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBiaXQ7IGJpdCA9IHRoaXNbaisrXTspe1xyXG4gICAgICAgICAgICBpZiAoaiAhPT0gMSkgeHByICs9IFwiIFwiXHJcbiAgICAgICAgICAgIGlmIChiaXQuY29tYmluYXRvciAhPT0gXCIgXCIpIHhwciArPSBiaXQuY29tYmluYXRvciArIFwiIFwiXHJcbiAgICAgICAgICAgIHhwciArPSBiaXRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmF3ID0geHByXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnJhd1xyXG59XHJcblxyXG52YXIgcmVwbGFjZXIgPSBmdW5jdGlvbihcclxuICAgIHJhd01hdGNoLFxyXG5cclxuICAgIHNlcGFyYXRvcixcclxuICAgIGNvbWJpbmF0b3IsXHJcbiAgICBjb21iaW5hdG9yQ2hpbGRyZW4sXHJcblxyXG4gICAgdGFnTmFtZSxcclxuICAgIGlkLFxyXG4gICAgY2xhc3NOYW1lLFxyXG5cclxuICAgIGF0dHJpYnV0ZUtleSxcclxuICAgIGF0dHJpYnV0ZU9wZXJhdG9yLFxyXG4gICAgYXR0cmlidXRlUXVvdGUsXHJcbiAgICBhdHRyaWJ1dGVWYWx1ZSxcclxuXHJcbiAgICBwc2V1ZG9NYXJrZXIsXHJcbiAgICBwc2V1ZG9DbGFzcyxcclxuICAgIHBzZXVkb1F1b3RlLFxyXG4gICAgcHNldWRvQ2xhc3NRdW90ZWRWYWx1ZSxcclxuICAgIHBzZXVkb0NsYXNzVmFsdWVcclxuKXtcclxuXHJcbiAgICB2YXIgZXhwcmVzc2lvbiwgY3VycmVudFxyXG5cclxuICAgIGlmIChzZXBhcmF0b3IgfHwgIXRoaXMubGVuZ3RoKXtcclxuICAgICAgICBleHByZXNzaW9uID0gdGhpc1t0aGlzLmxlbmd0aCsrXSA9IG5ldyBFeHByZXNzaW9uXHJcbiAgICAgICAgaWYgKHNlcGFyYXRvcikgcmV0dXJuICcnXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFleHByZXNzaW9uKSBleHByZXNzaW9uID0gdGhpc1t0aGlzLmxlbmd0aCAtIDFdXHJcblxyXG4gICAgaWYgKGNvbWJpbmF0b3IgfHwgY29tYmluYXRvckNoaWxkcmVuIHx8ICFleHByZXNzaW9uLmxlbmd0aCl7XHJcbiAgICAgICAgY3VycmVudCA9IGV4cHJlc3Npb25bZXhwcmVzc2lvbi5sZW5ndGgrK10gPSBuZXcgUGFydChjb21iaW5hdG9yKVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghY3VycmVudCkgY3VycmVudCA9IGV4cHJlc3Npb25bZXhwcmVzc2lvbi5sZW5ndGggLSAxXVxyXG5cclxuICAgIGlmICh0YWdOYW1lKXtcclxuXHJcbiAgICAgICAgY3VycmVudC50YWcgPSB1bmVzY2FwZSh0YWdOYW1lKVxyXG5cclxuICAgIH0gZWxzZSBpZiAoaWQpe1xyXG5cclxuICAgICAgICBjdXJyZW50LmlkID0gdW5lc2NhcGUoaWQpXHJcblxyXG4gICAgfSBlbHNlIGlmIChjbGFzc05hbWUpe1xyXG5cclxuICAgICAgICB2YXIgdW5lc2NhcGVkID0gdW5lc2NhcGUoY2xhc3NOYW1lKVxyXG5cclxuICAgICAgICB2YXIgY2xhc3NlcyA9IGN1cnJlbnQuY2xhc3NlcyB8fCAoY3VycmVudC5jbGFzc2VzID0ge30pXHJcbiAgICAgICAgaWYgKCFjbGFzc2VzW3VuZXNjYXBlZF0pe1xyXG4gICAgICAgICAgICBjbGFzc2VzW3VuZXNjYXBlZF0gPSBlc2NhcGUoY2xhc3NOYW1lKVxyXG4gICAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gY3VycmVudC5jbGFzc0xpc3QgfHwgKGN1cnJlbnQuY2xhc3NMaXN0ID0gW10pXHJcbiAgICAgICAgICAgIGNsYXNzTGlzdC5wdXNoKHVuZXNjYXBlZClcclxuICAgICAgICAgICAgY2xhc3NMaXN0LnNvcnQoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGVsc2UgaWYgKHBzZXVkb0NsYXNzKXtcclxuXHJcbiAgICAgICAgcHNldWRvQ2xhc3NWYWx1ZSA9IHBzZXVkb0NsYXNzVmFsdWUgfHwgcHNldWRvQ2xhc3NRdW90ZWRWYWx1ZVxyXG5cclxuICAgICAgICA7KGN1cnJlbnQucHNldWRvcyB8fCAoY3VycmVudC5wc2V1ZG9zID0gW10pKS5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZSAgICAgICAgIDogcHNldWRvTWFya2VyLmxlbmd0aCA9PSAxID8gJ2NsYXNzJyA6ICdlbGVtZW50JyxcclxuICAgICAgICAgICAgbmFtZSAgICAgICAgIDogdW5lc2NhcGUocHNldWRvQ2xhc3MpLFxyXG4gICAgICAgICAgICBlc2NhcGVkTmFtZSAgOiBlc2NhcGUocHNldWRvQ2xhc3MpLFxyXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgOiBwc2V1ZG9DbGFzc1ZhbHVlID8gdW5lc2NhcGUocHNldWRvQ2xhc3NWYWx1ZSkgOiBudWxsLFxyXG4gICAgICAgICAgICBlc2NhcGVkVmFsdWUgOiBwc2V1ZG9DbGFzc1ZhbHVlID8gZXNjYXBlKHBzZXVkb0NsYXNzVmFsdWUpIDogbnVsbFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVLZXkpe1xyXG5cclxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZVZhbHVlID8gZXNjYXBlKGF0dHJpYnV0ZVZhbHVlKSA6IG51bGxcclxuXHJcbiAgICAgICAgOyhjdXJyZW50LmF0dHJpYnV0ZXMgfHwgKGN1cnJlbnQuYXR0cmlidXRlcyA9IFtdKSkucHVzaCh7XHJcbiAgICAgICAgICAgIG9wZXJhdG9yICAgICA6IGF0dHJpYnV0ZU9wZXJhdG9yLFxyXG4gICAgICAgICAgICBuYW1lICAgICAgICAgOiB1bmVzY2FwZShhdHRyaWJ1dGVLZXkpLFxyXG4gICAgICAgICAgICBlc2NhcGVkTmFtZSAgOiBlc2NhcGUoYXR0cmlidXRlS2V5KSxcclxuICAgICAgICAgICAgdmFsdWUgICAgICAgIDogYXR0cmlidXRlVmFsdWUgPyB1bmVzY2FwZShhdHRyaWJ1dGVWYWx1ZSkgOiBudWxsLFxyXG4gICAgICAgICAgICBlc2NhcGVkVmFsdWUgOiBhdHRyaWJ1dGVWYWx1ZSA/IGVzY2FwZShhdHRyaWJ1dGVWYWx1ZSkgOiBudWxsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICcnXHJcblxyXG59XHJcblxyXG4vLyBFeHByZXNzaW9uc1xyXG5cclxudmFyIEV4cHJlc3Npb25zID0gZnVuY3Rpb24gRXhwcmVzc2lvbnMoZXhwcmVzc2lvbil7XHJcbiAgICB0aGlzLmxlbmd0aCA9IDBcclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXNcclxuXHJcbiAgICB2YXIgb3JpZ2luYWwgPSBleHByZXNzaW9uLCByZXBsYWNlZFxyXG5cclxuICAgIHdoaWxlIChleHByZXNzaW9uKXtcclxuICAgICAgICByZXBsYWNlZCA9IGV4cHJlc3Npb24ucmVwbGFjZShzbGlja1JlLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgaWYgKHJlcGxhY2VkID09PSBleHByZXNzaW9uKSB0aHJvdyBuZXcgRXJyb3Iob3JpZ2luYWwgKyAnIGlzIGFuIGludmFsaWQgZXhwcmVzc2lvbicpXHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IHJlcGxhY2VkXHJcbiAgICB9XHJcbn1cclxuXHJcbkV4cHJlc3Npb25zLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XHJcbiAgICBpZiAoIXRoaXMucmF3KXtcclxuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBleHByZXNzaW9uOyBleHByZXNzaW9uID0gdGhpc1tpKytdOykgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKVxyXG4gICAgICAgIHRoaXMucmF3ID0gZXhwcmVzc2lvbnMuam9pbihcIiwgXCIpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmF3XHJcbn1cclxuXHJcbnZhciBjYWNoZSA9IHt9XHJcblxyXG52YXIgcGFyc2UgPSBmdW5jdGlvbihleHByZXNzaW9uKXtcclxuICAgIGlmIChleHByZXNzaW9uID09IG51bGwpIHJldHVybiBudWxsXHJcbiAgICBleHByZXNzaW9uID0gKCcnICsgZXhwcmVzc2lvbikucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXHJcbiAgICByZXR1cm4gY2FjaGVbZXhwcmVzc2lvbl0gfHwgKGNhY2hlW2V4cHJlc3Npb25dID0gbmV3IEV4cHJlc3Npb25zKGV4cHJlc3Npb24pKVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvc2xpY2svcGFyc2VyLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!**************************************************!*\
  !*** multi ./assets/sass/style.scss ./js/app.js ***!
  \**************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./assets/sass/style.scss */2);
module.exports = __webpack_require__(/*! ./js/app.js */3);


/***/ }),
/* 2 */
/*!********************************!*\
  !*** ./assets/sass/style.scss ***!
  \********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Fzc2V0cy9zYXNzL3N0eWxlLnNjc3M/YjY3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3Nhc3Mvc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_slick__ = __webpack_require__(/*! slick */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_slick___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_slick__);\n//js/app.js\n\n//Require scripts\n__webpack_require__(/*! ./script */ 4);\n\n//Require Slick\n//require('script-loader!../node_modules/slick-carousel/slick/slick')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9hcHAuanM/NDFkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2pzL2FwcC5qc1xuXG4vL1JlcXVpcmUgc2NyaXB0c1xucmVxdWlyZSgnLi9zY3JpcHQnKVxuXG4vL1JlcXVpcmUgU2xpY2tcbi8vcmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuLi9ub2RlX21vZHVsZXMvc2xpY2stY2Fyb3VzZWwvc2xpY2svc2xpY2snKVxuaW1wb3J0IFNsaWNrIGZyb20gXCJzbGlja1wiXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8ganMvYXBwLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/*!**********************!*\
  !*** ./js/script.js ***!
  \**********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("console.log('ciao');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9zY3JpcHQuanM/MmY4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zb2xlLmxvZygnY2lhbycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGpzL3NjcmlwdC5qcyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/*!*************************************!*\
  !*** ./node_modules/slick/index.js ***!
  \*************************************/
/*! dynamic exports provided */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*\r\nslick\r\n*/\n\nmodule.exports = \"document\" in global ? __webpack_require__(/*! ./finder */ 7) : { parse: __webpack_require__(/*! ./parser */ 0) };\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvc2xpY2svaW5kZXguanM/NmI0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5zbGlja1xyXG4qL1widXNlIHN0cmljdFwiXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFwiZG9jdW1lbnRcIiBpbiBnbG9iYWwgPyByZXF1aXJlKFwiLi9maW5kZXJcIikgOiB7IHBhcnNlOiByZXF1aXJlKFwiLi9wYXJzZXJcIikgfVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL3NsaWNrL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcz9mY2RmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcbn0gY2F0Y2goZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxuXHRcdGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!**************************************!*\
  !*** ./node_modules/slick/finder.js ***!
  \**************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\nSlick Finder\r\n*/\n\n// Notable changes from Slick.Finder 1.0.x\n\n// faster bottom -> up expression matching\n// prefers mental sanity over *obsessive compulsive* milliseconds savings\n// uses prototypes instead of objects\n// tries to use matchesSelector smartly, whenever available\n// can populate objects as well as arrays\n// lots of stuff is broken or not implemented\n\nvar parse = __webpack_require__(/*! ./parser */ 0);\n\n// utilities\n\nvar index = 0,\n    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),\n    key = \"uid:\" + counter;\n\nvar uniqueID = function (n, xml) {\n    if (n === window) return \"window\";\n    if (n === document) return \"document\";\n    if (n === document.documentElement) return \"html\";\n\n    if (xml) {\n        var uid = n.getAttribute(key);\n        if (!uid) {\n            uid = (index++).toString(36);\n            n.setAttribute(key, uid);\n        }\n        return uid;\n    } else {\n        return n[key] || (n[key] = (index++).toString(36));\n    }\n};\n\nvar uniqueIDXML = function (n) {\n    return uniqueID(n, true);\n};\n\nvar isArray = Array.isArray || function (object) {\n    return Object.prototype.toString.call(object) === \"[object Array]\";\n};\n\n// tests\n\nvar uniqueIndex = 0;\n\nvar HAS = {\n\n    GET_ELEMENT_BY_ID: function (test, id) {\n        id = \"slick_\" + uniqueIndex++;\n        // checks if the document has getElementById, and it works\n        test.innerHTML = '<a id=\"' + id + '\"></a>';\n        return !!this.getElementById(id);\n    },\n\n    QUERY_SELECTOR: function (test) {\n        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child\n        test.innerHTML = '_<style>:nth-child(2){}</style>';\n\n        // checks if the document has querySelectorAll, and it works\n        test.innerHTML = '<a class=\"MiX\"></a>';\n\n        return test.querySelectorAll('.MiX').length === 1;\n    },\n\n    EXPANDOS: function (test, id) {\n        id = \"slick_\" + uniqueIndex++;\n        // checks if the document has elements that support expandos\n        test._custom_property_ = id;\n        return test._custom_property_ === id;\n    },\n\n    // TODO: use this ?\n\n    // CHECKED_QUERY_SELECTOR: function(test){\n    //\n    //     // checks if the document supports the checked query selector\n    //     test.innerHTML = '<select><option selected=\"selected\">a</option></select>'\n    //     return test.querySelectorAll(':checked').length === 1\n    // },\n\n    // TODO: use this ?\n\n    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){\n    //\n    //     // checks if the document supports the empty attribute query selector\n    //     test.innerHTML = '<a class=\"\"></a>'\n    //     return test.querySelectorAll('[class*=\"\"]').length === 1\n    // },\n\n    MATCHES_SELECTOR: function (test) {\n\n        test.className = \"MiX\";\n\n        // checks if the document has matchesSelector, and we can use it.\n\n        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector;\n\n        // if matchesSelector trows errors on incorrect syntax we can use it\n        if (matches) try {\n            matches.call(test, ':slick');\n        } catch (e) {\n            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)\n            return matches.call(test, \".MiX\") ? matches : false;\n        }\n\n        return false;\n    },\n\n    GET_ELEMENTS_BY_CLASS_NAME: function (test) {\n        test.innerHTML = '<a class=\"f\"></a><a class=\"b\"></a>';\n        if (test.getElementsByClassName('b').length !== 1) return false;\n\n        test.firstChild.className = 'b';\n        if (test.getElementsByClassName('b').length !== 2) return false;\n\n        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one\n        test.innerHTML = '<a class=\"a\"></a><a class=\"f b a\"></a>';\n        if (test.getElementsByClassName('a').length !== 2) return false;\n\n        // tests passed\n        return true;\n    },\n\n    // no need to know\n\n    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){\n    //     test.innerHTML = '<a name=\"'+ id +'\"></a><b id=\"'+ id +'\"></b>'\n    //     return this.getElementById(id) !== test.firstChild\n    // },\n\n    // this is always checked for and fixed\n\n    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){\n    //\n    //     // IE returns comment nodes for getElementsByTagName('*') for some documents\n    //     test.appendChild(this.createComment(''))\n    //     if (test.getElementsByTagName('*').length > 0) return false\n    //\n    //     // IE returns closed nodes (EG:\"</foo>\") for getElementsByTagName('*') for some documents\n    //     test.innerHTML = 'foo</foo>'\n    //     if (test.getElementsByTagName('*').length) return false\n    //\n    //     // tests passed\n    //     return true\n    // },\n\n    // this is always checked for and fixed\n\n    // STAR_QUERY_SELECTOR: function(test){\n    //\n    //     // returns closed nodes (EG:\"</foo>\") for querySelector('*') for some documents\n    //     test.innerHTML = 'foo</foo>'\n    //     return !!(test.querySelectorAll('*').length)\n    // },\n\n    GET_ATTRIBUTE: function (test) {\n        // tests for working getAttribute implementation\n        var shout = \"fus ro dah\";\n        test.innerHTML = '<a class=\"' + shout + '\"></a>';\n        return test.firstChild.getAttribute('class') === shout;\n    }\n\n    // Finder\n\n};var Finder = function Finder(document) {\n\n    this.document = document;\n    var root = this.root = document.documentElement;\n    this.tested = {};\n\n    // uniqueID\n\n    this.uniqueID = this.has(\"EXPANDOS\") ? uniqueID : uniqueIDXML;\n\n    // getAttribute\n\n    this.getAttribute = this.has(\"GET_ATTRIBUTE\") ? function (node, name) {\n\n        return node.getAttribute(name);\n    } : function (node, name) {\n\n        node = node.getAttributeNode(name);\n        return node && node.specified ? node.value : null;\n    };\n\n    // hasAttribute\n\n    this.hasAttribute = root.hasAttribute ? function (node, attribute) {\n\n        return node.hasAttribute(attribute);\n    } : function (node, attribute) {\n\n        node = node.getAttributeNode(attribute);\n        return !!(node && node.specified);\n    };\n\n    // contains\n\n    this.contains = document.contains && root.contains ? function (context, node) {\n\n        return context.contains(node);\n    } : root.compareDocumentPosition ? function (context, node) {\n\n        return context === node || !!(context.compareDocumentPosition(node) & 16);\n    } : function (context, node) {\n\n        do {\n            if (node === context) return true;\n        } while (node = node.parentNode);\n\n        return false;\n    };\n\n    // sort\n    // credits to Sizzle (http://sizzlejs.com/)\n\n    this.sorter = root.compareDocumentPosition ? function (a, b) {\n\n        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0;\n        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;\n    } : 'sourceIndex' in root ? function (a, b) {\n\n        if (!a.sourceIndex || !b.sourceIndex) return 0;\n        return a.sourceIndex - b.sourceIndex;\n    } : document.createRange ? function (a, b) {\n\n        if (!a.ownerDocument || !b.ownerDocument) return 0;\n        var aRange = a.ownerDocument.createRange(),\n            bRange = b.ownerDocument.createRange();\n\n        aRange.setStart(a, 0);\n        aRange.setEnd(a, 0);\n        bRange.setStart(b, 0);\n        bRange.setEnd(b, 0);\n        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange);\n    } : null;\n\n    this.failed = {};\n\n    var nativeMatches = this.has(\"MATCHES_SELECTOR\");\n\n    if (nativeMatches) this.matchesSelector = function (node, expression) {\n\n        if (this.failed[expression]) return null;\n\n        try {\n            return nativeMatches.call(node, expression);\n        } catch (e) {\n            if (slick.debug) console.warn(\"matchesSelector failed on \" + expression);\n            this.failed[expression] = true;\n            return null;\n        }\n    };\n\n    if (this.has(\"QUERY_SELECTOR\")) {\n\n        this.querySelectorAll = function (node, expression) {\n\n            if (this.failed[expression]) return true;\n\n            var result, _id, _expression, _combinator, _node;\n\n            // non-document rooted QSA\n            // credits to Andrew Dupont\n\n            if (node !== this.document) {\n\n                _combinator = expression[0].combinator;\n\n                _id = node.getAttribute(\"id\");\n                _expression = expression;\n\n                if (!_id) {\n                    _node = node;\n                    _id = \"__slick__\";\n                    _node.setAttribute(\"id\", _id);\n                }\n\n                expression = \"#\" + _id + \" \" + _expression;\n\n                // these combinators need a parentNode due to how querySelectorAll works, which is:\n                // finding all the elements that match the given selector\n                // then filtering by the ones that have the specified element as an ancestor\n                if (_combinator.indexOf(\"~\") > -1 || _combinator.indexOf(\"+\") > -1) {\n\n                    node = node.parentNode;\n                    if (!node) result = true;\n                    // if node has no parentNode, we return \"true\" as if it failed, without polluting the failed cache\n                }\n            }\n\n            if (!result) try {\n                result = node.querySelectorAll(expression.toString());\n            } catch (e) {\n                if (slick.debug) console.warn(\"querySelectorAll failed on \" + (_expression || expression));\n                result = this.failed[_expression || expression] = true;\n            }\n\n            if (_node) _node.removeAttribute(\"id\");\n\n            return result;\n        };\n    }\n};\n\nFinder.prototype.has = function (FEATURE) {\n\n    var tested = this.tested,\n        testedFEATURE = tested[FEATURE];\n\n    if (testedFEATURE != null) return testedFEATURE;\n\n    var root = this.root,\n        document = this.document,\n        testNode = document.createElement(\"div\");\n\n    testNode.setAttribute(\"style\", \"display: none;\");\n\n    root.appendChild(testNode);\n\n    var TEST = HAS[FEATURE],\n        result = false;\n\n    if (TEST) try {\n        result = TEST.call(document, testNode);\n    } catch (e) {}\n\n    if (slick.debug && !result) console.warn(\"document has no \" + FEATURE);\n\n    root.removeChild(testNode);\n\n    return tested[FEATURE] = result;\n};\n\nvar combinators = {\n\n    \" \": function (node, part, push) {\n\n        var item, items;\n\n        var noId = !part.id,\n            noTag = !part.tag,\n            noClass = !part.classes;\n\n        if (part.id && node.getElementById && this.has(\"GET_ELEMENT_BY_ID\")) {\n            item = node.getElementById(part.id);\n\n            // return only if id is found, else keep checking\n            // might be a tad slower on non-existing ids, but less insane\n\n            if (item && item.getAttribute('id') === part.id) {\n                items = [item];\n                noId = true;\n                // if tag is star, no need to check it in match()\n                if (part.tag === \"*\") noTag = true;\n            }\n        }\n\n        if (!items) {\n\n            if (part.classes && node.getElementsByClassName && this.has(\"GET_ELEMENTS_BY_CLASS_NAME\")) {\n                items = node.getElementsByClassName(part.classList);\n                noClass = true;\n                // if tag is star, no need to check it in match()\n                if (part.tag === \"*\") noTag = true;\n            } else {\n                items = node.getElementsByTagName(part.tag);\n                // if tag is star, need to check it in match because it could select junk, boho\n                if (part.tag !== \"*\") noTag = true;\n            }\n\n            if (!items || !items.length) return false;\n        }\n\n        for (var i = 0; item = items[i++];) if (noTag && noId && noClass && !part.attributes && !part.pseudos || this.match(item, part, noTag, noId, noClass)) push(item);\n\n        return true;\n    },\n\n    \">\": function (node, part, push) {\n        // direct children\n        if (node = node.firstChild) do {\n            if (node.nodeType == 1 && this.match(node, part)) push(node);\n        } while (node = node.nextSibling);\n    },\n\n    \"+\": function (node, part, push) {\n        // next sibling\n        while (node = node.nextSibling) if (node.nodeType == 1) {\n            if (this.match(node, part)) push(node);\n            break;\n        }\n    },\n\n    \"^\": function (node, part, push) {\n        // first child\n        node = node.firstChild;\n        if (node) {\n            if (node.nodeType === 1) {\n                if (this.match(node, part)) push(node);\n            } else {\n                combinators['+'].call(this, node, part, push);\n            }\n        }\n    },\n\n    \"~\": function (node, part, push) {\n        // next siblings\n        while (node = node.nextSibling) {\n            if (node.nodeType === 1 && this.match(node, part)) push(node);\n        }\n    },\n\n    \"++\": function (node, part, push) {\n        // next sibling and previous sibling\n        combinators['+'].call(this, node, part, push);\n        combinators['!+'].call(this, node, part, push);\n    },\n\n    \"~~\": function (node, part, push) {\n        // next siblings and previous siblings\n        combinators['~'].call(this, node, part, push);\n        combinators['!~'].call(this, node, part, push);\n    },\n\n    \"!\": function (node, part, push) {\n        // all parent nodes up to document\n        while (node = node.parentNode) if (node !== this.document && this.match(node, part)) push(node);\n    },\n\n    \"!>\": function (node, part, push) {\n        // direct parent (one level)\n        node = node.parentNode;\n        if (node !== this.document && this.match(node, part)) push(node);\n    },\n\n    \"!+\": function (node, part, push) {\n        // previous sibling\n        while (node = node.previousSibling) if (node.nodeType == 1) {\n            if (this.match(node, part)) push(node);\n            break;\n        }\n    },\n\n    \"!^\": function (node, part, push) {\n        // last child\n        node = node.lastChild;\n        if (node) {\n            if (node.nodeType == 1) {\n                if (this.match(node, part)) push(node);\n            } else {\n                combinators['!+'].call(this, node, part, push);\n            }\n        }\n    },\n\n    \"!~\": function (node, part, push) {\n        // previous siblings\n        while (node = node.previousSibling) {\n            if (node.nodeType === 1 && this.match(node, part)) push(node);\n        }\n    }\n\n};\n\nFinder.prototype.search = function (context, expression, found) {\n\n    if (!context) context = this.document;else if (!context.nodeType && context.document) context = context.document;\n\n    var expressions = parse(expression);\n\n    // no expressions were parsed. todo: is this really necessary?\n    if (!expressions || !expressions.length) throw new Error(\"invalid expression\");\n\n    if (!found) found = [];\n\n    var uniques,\n        push = isArray(found) ? function (node) {\n        found[found.length] = node;\n    } : function (node) {\n        found[found.length++] = node;\n    };\n\n    // if there is more than one expression we need to check for duplicates when we push to found\n    // this simply saves the old push and wraps it around an uid dupe check.\n    if (expressions.length > 1) {\n        uniques = {};\n        var plush = push;\n        push = function (node) {\n            var uid = uniqueID(node);\n            if (!uniques[uid]) {\n                uniques[uid] = true;\n                plush(node);\n            }\n        };\n    }\n\n    // walker\n\n    var node, nodes, part;\n\n    main: for (var i = 0; expression = expressions[i++];) {\n\n        // querySelector\n\n        // TODO: more functional tests\n\n        // if there is querySelectorAll (and the expression does not fail) use it.\n        if (!slick.noQSA && this.querySelectorAll) {\n\n            nodes = this.querySelectorAll(context, expression);\n            if (nodes !== true) {\n                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@') {\n                    push(node);\n                }\n                continue main;\n            }\n        }\n\n        // if there is only one part in the expression we don't need to check each part for duplicates.\n        // todo: this might be too naive. while solid, there can be expression sequences that do not\n        // produce duplicates. \"body div\" for instance, can never give you each div more than once.\n        // \"body div a\" on the other hand might.\n        if (expression.length === 1) {\n\n            part = expression[0];\n            combinators[part.combinator].call(this, context, part, push);\n        } else {\n\n            var cs = [context],\n                c,\n                f,\n                u,\n                p = function (node) {\n                var uid = uniqueID(node);\n                if (!u[uid]) {\n                    u[uid] = true;\n                    f[f.length] = node;\n                }\n            };\n\n            // loop the expression parts\n            for (var j = 0; part = expression[j++];) {\n                f = [];u = {};\n                // loop the contexts\n                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p);\n                // nothing was found, the expression failed, continue to the next expression.\n                if (!f.length) continue main;\n                cs = f; // set the contexts for future parts (if any)\n            }\n\n            if (i === 0) found = f; // first expression. directly set found.\n            else for (var l = 0; l < f.length; l++) push(f[l]); // any other expression needs to push to found.\n        }\n    }\n\n    if (uniques && found && found.length > 1) this.sort(found);\n\n    return found;\n};\n\nFinder.prototype.sort = function (nodes) {\n    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes;\n};\n\n// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.\n\nvar pseudos = {\n\n    // TODO: returns different results than qsa empty.\n\n    'empty': function () {\n        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length;\n    },\n\n    'not': function (expression) {\n        return !slick.matches(this, expression);\n    },\n\n    'contains': function (text) {\n        return (this.innerText || this.textContent || '').indexOf(text) > -1;\n    },\n\n    'first-child': function () {\n        var node = this;\n        while (node = node.previousSibling) if (node.nodeType == 1) return false;\n        return true;\n    },\n\n    'last-child': function () {\n        var node = this;\n        while (node = node.nextSibling) if (node.nodeType == 1) return false;\n        return true;\n    },\n\n    'only-child': function () {\n        var prev = this;\n        while (prev = prev.previousSibling) if (prev.nodeType == 1) return false;\n\n        var next = this;\n        while (next = next.nextSibling) if (next.nodeType == 1) return false;\n\n        return true;\n    },\n\n    'first-of-type': function () {\n        var node = this,\n            nodeName = node.nodeName;\n        while (node = node.previousSibling) if (node.nodeName == nodeName) return false;\n        return true;\n    },\n\n    'last-of-type': function () {\n        var node = this,\n            nodeName = node.nodeName;\n        while (node = node.nextSibling) if (node.nodeName == nodeName) return false;\n        return true;\n    },\n\n    'only-of-type': function () {\n        var prev = this,\n            nodeName = this.nodeName;\n        while (prev = prev.previousSibling) if (prev.nodeName == nodeName) return false;\n        var next = this;\n        while (next = next.nextSibling) if (next.nodeName == nodeName) return false;\n        return true;\n    },\n\n    'enabled': function () {\n        return !this.disabled;\n    },\n\n    'disabled': function () {\n        return this.disabled;\n    },\n\n    'checked': function () {\n        return this.checked || this.selected;\n    },\n\n    'selected': function () {\n        return this.selected;\n    },\n\n    'focus': function () {\n        var doc = this.ownerDocument;\n        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'));\n    },\n\n    'root': function () {\n        return this === this.ownerDocument.documentElement;\n    }\n\n};\n\nFinder.prototype.match = function (node, bit, noTag, noId, noClass) {\n\n    // TODO: more functional tests ?\n\n    if (!slick.noQSA && this.matchesSelector) {\n        var matches = this.matchesSelector(node, bit);\n        if (matches !== null) return matches;\n    }\n\n    // normal matching\n\n    if (!noTag && bit.tag) {\n\n        var nodeName = node.nodeName.toLowerCase();\n        if (bit.tag === \"*\") {\n            if (nodeName < \"@\") return false;\n        } else if (nodeName != bit.tag) {\n            return false;\n        }\n    }\n\n    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false;\n\n    var i, part;\n\n    if (!noClass && bit.classes) {\n\n        var className = this.getAttribute(node, \"class\");\n        if (!className) return false;\n\n        for (part in bit.classes) if (!RegExp('(^|\\\\s)' + bit.classes[part] + '(\\\\s|$)').test(className)) return false;\n    }\n\n    var name, value;\n\n    if (bit.attributes) for (i = 0; part = bit.attributes[i++];) {\n\n        var operator = part.operator,\n            escaped = part.escapedValue;\n\n        name = part.name;\n        value = part.value;\n\n        if (!operator) {\n\n            if (!this.hasAttribute(node, name)) return false;\n        } else {\n\n            var actual = this.getAttribute(node, name);\n            if (actual == null) return false;\n\n            switch (operator) {\n                case '^=':\n                    if (!RegExp('^' + escaped).test(actual)) return false;break;\n                case '$=':\n                    if (!RegExp(escaped + '$').test(actual)) return false;break;\n                case '~=':\n                    if (!RegExp('(^|\\\\s)' + escaped + '(\\\\s|$)').test(actual)) return false;break;\n                case '|=':\n                    if (!RegExp('^' + escaped + '(-|$)').test(actual)) return false;break;\n\n                case '=':\n                    if (actual !== value) return false;break;\n                case '*=':\n                    if (actual.indexOf(value) === -1) return false;break;\n                default:\n                    return false;\n            }\n        }\n    }\n\n    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];) {\n\n        name = part.name;\n        value = part.value;\n\n        if (pseudos[name]) return pseudos[name].call(node, value);\n\n        if (value != null) {\n            if (this.getAttribute(node, name) !== value) return false;\n        } else {\n            if (!this.hasAttribute(node, name)) return false;\n        }\n    }\n\n    return true;\n};\n\nFinder.prototype.matches = function (node, expression) {\n\n    var expressions = parse(expression);\n\n    if (expressions.length === 1 && expressions[0].length === 1) {\n        // simplest match\n        return this.match(node, expressions[0][0]);\n    }\n\n    // TODO: more functional tests ?\n\n    if (!slick.noQSA && this.matchesSelector) {\n        var matches = this.matchesSelector(node, expressions);\n        if (matches !== null) return matches;\n    }\n\n    var nodes = this.search(this.document, expression, { length: 0 });\n\n    for (var i = 0, res; res = nodes[i++];) if (node === res) return true;\n    return false;\n};\n\nvar finders = {};\n\nvar finder = function (context) {\n    var doc = context || document;\n    if (doc.ownerDocument) doc = doc.ownerDocument;else if (doc.document) doc = doc.document;\n\n    if (doc.nodeType !== 9) throw new TypeError(\"invalid document\");\n\n    var uid = uniqueID(doc);\n    return finders[uid] || (finders[uid] = new Finder(doc));\n};\n\n// ... API ...\n\nvar slick = function (expression, context) {\n    return slick.search(expression, context);\n};\n\nslick.search = function (expression, context, found) {\n    return finder(context).search(context, expression, found);\n};\n\nslick.find = function (expression, context) {\n    return finder(context).search(context, expression)[0] || null;\n};\n\nslick.getAttribute = function (node, name) {\n    return finder(node).getAttribute(node, name);\n};\n\nslick.hasAttribute = function (node, name) {\n    return finder(node).hasAttribute(node, name);\n};\n\nslick.contains = function (context, node) {\n    return finder(context).contains(context, node);\n};\n\nslick.matches = function (node, expression) {\n    return finder(node).matches(node, expression);\n};\n\nslick.sort = function (nodes) {\n    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes);\n    return nodes;\n};\n\nslick.parse = parse;\n\n// slick.debug = true\n// slick.noQSA  = true\n\nmodule.exports = slick;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvc2xpY2svZmluZGVyLmpzP2RhMTIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuU2xpY2sgRmluZGVyXHJcbiovXCJ1c2Ugc3RyaWN0XCJcclxuXHJcbi8vIE5vdGFibGUgY2hhbmdlcyBmcm9tIFNsaWNrLkZpbmRlciAxLjAueFxyXG5cclxuLy8gZmFzdGVyIGJvdHRvbSAtPiB1cCBleHByZXNzaW9uIG1hdGNoaW5nXHJcbi8vIHByZWZlcnMgbWVudGFsIHNhbml0eSBvdmVyICpvYnNlc3NpdmUgY29tcHVsc2l2ZSogbWlsbGlzZWNvbmRzIHNhdmluZ3NcclxuLy8gdXNlcyBwcm90b3R5cGVzIGluc3RlYWQgb2Ygb2JqZWN0c1xyXG4vLyB0cmllcyB0byB1c2UgbWF0Y2hlc1NlbGVjdG9yIHNtYXJ0bHksIHdoZW5ldmVyIGF2YWlsYWJsZVxyXG4vLyBjYW4gcG9wdWxhdGUgb2JqZWN0cyBhcyB3ZWxsIGFzIGFycmF5c1xyXG4vLyBsb3RzIG9mIHN0dWZmIGlzIGJyb2tlbiBvciBub3QgaW1wbGVtZW50ZWRcclxuXHJcbnZhciBwYXJzZSA9IHJlcXVpcmUoXCIuL3BhcnNlclwiKVxyXG5cclxuLy8gdXRpbGl0aWVzXHJcblxyXG52YXIgaW5kZXggPSAwLFxyXG4gICAgY291bnRlciA9IGRvY3VtZW50Ll9fY291bnRlciA9IChwYXJzZUludChkb2N1bWVudC5fX2NvdW50ZXIgfHwgLTEsIDM2KSArIDEpLnRvU3RyaW5nKDM2KSxcclxuICAgIGtleSA9IFwidWlkOlwiICsgY291bnRlclxyXG5cclxudmFyIHVuaXF1ZUlEID0gZnVuY3Rpb24obiwgeG1sKXtcclxuICAgIGlmIChuID09PSB3aW5kb3cpIHJldHVybiBcIndpbmRvd1wiXHJcbiAgICBpZiAobiA9PT0gZG9jdW1lbnQpIHJldHVybiBcImRvY3VtZW50XCJcclxuICAgIGlmIChuID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHJldHVybiBcImh0bWxcIlxyXG5cclxuICAgIGlmICh4bWwpIHtcclxuICAgICAgICB2YXIgdWlkID0gbi5nZXRBdHRyaWJ1dGUoa2V5KVxyXG4gICAgICAgIGlmICghdWlkKSB7XHJcbiAgICAgICAgICAgIHVpZCA9IChpbmRleCsrKS50b1N0cmluZygzNilcclxuICAgICAgICAgICAgbi5zZXRBdHRyaWJ1dGUoa2V5LCB1aWQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1aWRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ba2V5XSB8fCAobltrZXldID0gKGluZGV4KyspLnRvU3RyaW5nKDM2KSlcclxuICAgIH1cclxufVxyXG5cclxudmFyIHVuaXF1ZUlEWE1MID0gZnVuY3Rpb24obikge1xyXG4gICAgcmV0dXJuIHVuaXF1ZUlEKG4sIHRydWUpXHJcbn1cclxuXHJcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmplY3Qpe1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSBcIltvYmplY3QgQXJyYXldXCJcclxufVxyXG5cclxuLy8gdGVzdHNcclxuXHJcbnZhciB1bmlxdWVJbmRleCA9IDA7XHJcblxyXG52YXIgSEFTID0ge1xyXG5cclxuICAgIEdFVF9FTEVNRU5UX0JZX0lEOiBmdW5jdGlvbih0ZXN0LCBpZCl7XHJcbiAgICAgICAgaWQgPSBcInNsaWNrX1wiICsgKHVuaXF1ZUluZGV4KyspO1xyXG4gICAgICAgIC8vIGNoZWNrcyBpZiB0aGUgZG9jdW1lbnQgaGFzIGdldEVsZW1lbnRCeUlkLCBhbmQgaXQgd29ya3NcclxuICAgICAgICB0ZXN0LmlubmVySFRNTCA9ICc8YSBpZD1cIicgKyBpZCArICdcIj48L2E+J1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0RWxlbWVudEJ5SWQoaWQpXHJcbiAgICB9LFxyXG5cclxuICAgIFFVRVJZX1NFTEVDVE9SOiBmdW5jdGlvbih0ZXN0KXtcclxuICAgICAgICAvLyB0aGlzIHN1cHBvc2VkbHkgZml4ZXMgYSB3ZWJraXQgYnVnIHdpdGggbWF0Y2hlc1NlbGVjdG9yIC8gcXVlcnlTZWxlY3RvciAmIG50aC1jaGlsZFxyXG4gICAgICAgIHRlc3QuaW5uZXJIVE1MID0gJ188c3R5bGU+Om50aC1jaGlsZCgyKXt9PC9zdHlsZT4nXHJcblxyXG4gICAgICAgIC8vIGNoZWNrcyBpZiB0aGUgZG9jdW1lbnQgaGFzIHF1ZXJ5U2VsZWN0b3JBbGwsIGFuZCBpdCB3b3Jrc1xyXG4gICAgICAgIHRlc3QuaW5uZXJIVE1MID0gJzxhIGNsYXNzPVwiTWlYXCI+PC9hPidcclxuXHJcbiAgICAgICAgcmV0dXJuIHRlc3QucXVlcnlTZWxlY3RvckFsbCgnLk1pWCcpLmxlbmd0aCA9PT0gMVxyXG4gICAgfSxcclxuXHJcbiAgICBFWFBBTkRPUzogZnVuY3Rpb24odGVzdCwgaWQpe1xyXG4gICAgICAgIGlkID0gXCJzbGlja19cIiArICh1bmlxdWVJbmRleCsrKTtcclxuICAgICAgICAvLyBjaGVja3MgaWYgdGhlIGRvY3VtZW50IGhhcyBlbGVtZW50cyB0aGF0IHN1cHBvcnQgZXhwYW5kb3NcclxuICAgICAgICB0ZXN0Ll9jdXN0b21fcHJvcGVydHlfID0gaWRcclxuICAgICAgICByZXR1cm4gdGVzdC5fY3VzdG9tX3Byb3BlcnR5XyA9PT0gaWRcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVE9ETzogdXNlIHRoaXMgP1xyXG5cclxuICAgIC8vIENIRUNLRURfUVVFUllfU0VMRUNUT1I6IGZ1bmN0aW9uKHRlc3Qpe1xyXG4gICAgLy9cclxuICAgIC8vICAgICAvLyBjaGVja3MgaWYgdGhlIGRvY3VtZW50IHN1cHBvcnRzIHRoZSBjaGVja2VkIHF1ZXJ5IHNlbGVjdG9yXHJcbiAgICAvLyAgICAgdGVzdC5pbm5lckhUTUwgPSAnPHNlbGVjdD48b3B0aW9uIHNlbGVjdGVkPVwic2VsZWN0ZWRcIj5hPC9vcHRpb24+PC9zZWxlY3Q+J1xyXG4gICAgLy8gICAgIHJldHVybiB0ZXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJykubGVuZ3RoID09PSAxXHJcbiAgICAvLyB9LFxyXG5cclxuICAgIC8vIFRPRE86IHVzZSB0aGlzID9cclxuXHJcbiAgICAvLyBFTVBUWV9BVFRSSUJVVEVfUVVFUllfU0VMRUNUT1I6IGZ1bmN0aW9uKHRlc3Qpe1xyXG4gICAgLy9cclxuICAgIC8vICAgICAvLyBjaGVja3MgaWYgdGhlIGRvY3VtZW50IHN1cHBvcnRzIHRoZSBlbXB0eSBhdHRyaWJ1dGUgcXVlcnkgc2VsZWN0b3JcclxuICAgIC8vICAgICB0ZXN0LmlubmVySFRNTCA9ICc8YSBjbGFzcz1cIlwiPjwvYT4nXHJcbiAgICAvLyAgICAgcmV0dXJuIHRlc3QucXVlcnlTZWxlY3RvckFsbCgnW2NsYXNzKj1cIlwiXScpLmxlbmd0aCA9PT0gMVxyXG4gICAgLy8gfSxcclxuXHJcbiAgICBNQVRDSEVTX1NFTEVDVE9SOiBmdW5jdGlvbih0ZXN0KXtcclxuXHJcbiAgICAgICAgdGVzdC5jbGFzc05hbWUgPSBcIk1pWFwiXHJcblxyXG4gICAgICAgIC8vIGNoZWNrcyBpZiB0aGUgZG9jdW1lbnQgaGFzIG1hdGNoZXNTZWxlY3RvciwgYW5kIHdlIGNhbiB1c2UgaXQuXHJcblxyXG4gICAgICAgIHZhciBtYXRjaGVzID0gdGVzdC5tYXRjaGVzU2VsZWN0b3IgfHwgdGVzdC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgdGVzdC53ZWJraXRNYXRjaGVzU2VsZWN0b3JcclxuXHJcbiAgICAgICAgLy8gaWYgbWF0Y2hlc1NlbGVjdG9yIHRyb3dzIGVycm9ycyBvbiBpbmNvcnJlY3Qgc3ludGF4IHdlIGNhbiB1c2UgaXRcclxuICAgICAgICBpZiAobWF0Y2hlcykgdHJ5IHtcclxuICAgICAgICAgICAgbWF0Y2hlcy5jYWxsKHRlc3QsICc6c2xpY2snKVxyXG4gICAgICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgICAgIC8vIGp1c3QgYXMgYSBzYWZldHkgcHJlY2F1dGlvbiwgYWxzbyB0ZXN0IGlmIGl0IHdvcmtzIG9uIG1peGVkY2FzZSAobGlrZSBxdWVyeVNlbGVjdG9yQWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcy5jYWxsKHRlc3QsIFwiLk1pWFwiKSA/IG1hdGNoZXMgOiBmYWxzZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9LFxyXG5cclxuICAgIEdFVF9FTEVNRU5UU19CWV9DTEFTU19OQU1FOiBmdW5jdGlvbih0ZXN0KXtcclxuICAgICAgICB0ZXN0LmlubmVySFRNTCA9ICc8YSBjbGFzcz1cImZcIj48L2E+PGEgY2xhc3M9XCJiXCI+PC9hPidcclxuICAgICAgICBpZiAodGVzdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdiJykubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgdGVzdC5maXJzdENoaWxkLmNsYXNzTmFtZSA9ICdiJ1xyXG4gICAgICAgIGlmICh0ZXN0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2InKS5sZW5ndGggIT09IDIpIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgICAvLyBPcGVyYSA5LjYgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSBkb2VzbnQgZGV0ZWN0cyB0aGUgY2xhc3MgaWYgaXRzIG5vdCB0aGUgZmlyc3Qgb25lXHJcbiAgICAgICAgdGVzdC5pbm5lckhUTUwgPSAnPGEgY2xhc3M9XCJhXCI+PC9hPjxhIGNsYXNzPVwiZiBiIGFcIj48L2E+J1xyXG4gICAgICAgIGlmICh0ZXN0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2EnKS5sZW5ndGggIT09IDIpIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgICAvLyB0ZXN0cyBwYXNzZWRcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBubyBuZWVkIHRvIGtub3dcclxuXHJcbiAgICAvLyBHRVRfRUxFTUVOVF9CWV9JRF9OT1RfTkFNRTogZnVuY3Rpb24odGVzdCwgaWQpe1xyXG4gICAgLy8gICAgIHRlc3QuaW5uZXJIVE1MID0gJzxhIG5hbWU9XCInKyBpZCArJ1wiPjwvYT48YiBpZD1cIicrIGlkICsnXCI+PC9iPidcclxuICAgIC8vICAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50QnlJZChpZCkgIT09IHRlc3QuZmlyc3RDaGlsZFxyXG4gICAgLy8gfSxcclxuXHJcbiAgICAvLyB0aGlzIGlzIGFsd2F5cyBjaGVja2VkIGZvciBhbmQgZml4ZWRcclxuXHJcbiAgICAvLyBTVEFSX0dFVF9FTEVNRU5UU19CWV9UQUdfTkFNRTogZnVuY3Rpb24odGVzdCl7XHJcbiAgICAvL1xyXG4gICAgLy8gICAgIC8vIElFIHJldHVybnMgY29tbWVudCBub2RlcyBmb3IgZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSBmb3Igc29tZSBkb2N1bWVudHNcclxuICAgIC8vICAgICB0ZXN0LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlQ29tbWVudCgnJykpXHJcbiAgICAvLyAgICAgaWYgKHRlc3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKS5sZW5ndGggPiAwKSByZXR1cm4gZmFsc2VcclxuICAgIC8vXHJcbiAgICAvLyAgICAgLy8gSUUgcmV0dXJucyBjbG9zZWQgbm9kZXMgKEVHOlwiPC9mb28+XCIpIGZvciBnZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpIGZvciBzb21lIGRvY3VtZW50c1xyXG4gICAgLy8gICAgIHRlc3QuaW5uZXJIVE1MID0gJ2ZvbzwvZm9vPidcclxuICAgIC8vICAgICBpZiAodGVzdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpLmxlbmd0aCkgcmV0dXJuIGZhbHNlXHJcbiAgICAvL1xyXG4gICAgLy8gICAgIC8vIHRlc3RzIHBhc3NlZFxyXG4gICAgLy8gICAgIHJldHVybiB0cnVlXHJcbiAgICAvLyB9LFxyXG5cclxuICAgIC8vIHRoaXMgaXMgYWx3YXlzIGNoZWNrZWQgZm9yIGFuZCBmaXhlZFxyXG5cclxuICAgIC8vIFNUQVJfUVVFUllfU0VMRUNUT1I6IGZ1bmN0aW9uKHRlc3Qpe1xyXG4gICAgLy9cclxuICAgIC8vICAgICAvLyByZXR1cm5zIGNsb3NlZCBub2RlcyAoRUc6XCI8L2Zvbz5cIikgZm9yIHF1ZXJ5U2VsZWN0b3IoJyonKSBmb3Igc29tZSBkb2N1bWVudHNcclxuICAgIC8vICAgICB0ZXN0LmlubmVySFRNTCA9ICdmb288L2Zvbz4nXHJcbiAgICAvLyAgICAgcmV0dXJuICEhKHRlc3QucXVlcnlTZWxlY3RvckFsbCgnKicpLmxlbmd0aClcclxuICAgIC8vIH0sXHJcblxyXG4gICAgR0VUX0FUVFJJQlVURTogZnVuY3Rpb24odGVzdCl7XHJcbiAgICAgICAgLy8gdGVzdHMgZm9yIHdvcmtpbmcgZ2V0QXR0cmlidXRlIGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgdmFyIHNob3V0ID0gXCJmdXMgcm8gZGFoXCJcclxuICAgICAgICB0ZXN0LmlubmVySFRNTCA9ICc8YSBjbGFzcz1cIicgKyBzaG91dCArICdcIj48L2E+J1xyXG4gICAgICAgIHJldHVybiB0ZXN0LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCdjbGFzcycpID09PSBzaG91dFxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuLy8gRmluZGVyXHJcblxyXG52YXIgRmluZGVyID0gZnVuY3Rpb24gRmluZGVyKGRvY3VtZW50KXtcclxuXHJcbiAgICB0aGlzLmRvY3VtZW50ICAgICAgICA9IGRvY3VtZW50XHJcbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxyXG4gICAgdGhpcy50ZXN0ZWQgICAgICAgICAgPSB7fVxyXG5cclxuICAgIC8vIHVuaXF1ZUlEXHJcblxyXG4gICAgdGhpcy51bmlxdWVJRCA9IHRoaXMuaGFzKFwiRVhQQU5ET1NcIikgPyB1bmlxdWVJRCA6IHVuaXF1ZUlEWE1MXHJcblxyXG4gICAgLy8gZ2V0QXR0cmlidXRlXHJcblxyXG4gICAgdGhpcy5nZXRBdHRyaWJ1dGUgPSAodGhpcy5oYXMoXCJHRVRfQVRUUklCVVRFXCIpKSA/IGZ1bmN0aW9uKG5vZGUsIG5hbWUpe1xyXG5cclxuICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSlcclxuXHJcbiAgICB9IDogZnVuY3Rpb24obm9kZSwgbmFtZSl7XHJcblxyXG4gICAgICAgIG5vZGUgPSBub2RlLmdldEF0dHJpYnV0ZU5vZGUobmFtZSlcclxuICAgICAgICByZXR1cm4gKG5vZGUgJiYgbm9kZS5zcGVjaWZpZWQpID8gbm9kZS52YWx1ZSA6IG51bGxcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gaGFzQXR0cmlidXRlXHJcblxyXG4gICAgdGhpcy5oYXNBdHRyaWJ1dGUgPSAocm9vdC5oYXNBdHRyaWJ1dGUpID8gZnVuY3Rpb24obm9kZSwgYXR0cmlidXRlKXtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSlcclxuXHJcbiAgICB9IDogZnVuY3Rpb24obm9kZSwgYXR0cmlidXRlKSB7XHJcblxyXG4gICAgICAgIG5vZGUgPSBub2RlLmdldEF0dHJpYnV0ZU5vZGUoYXR0cmlidXRlKVxyXG4gICAgICAgIHJldHVybiAhIShub2RlICYmIG5vZGUuc3BlY2lmaWVkKVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBjb250YWluc1xyXG5cclxuICAgIHRoaXMuY29udGFpbnMgPSAoZG9jdW1lbnQuY29udGFpbnMgJiYgcm9vdC5jb250YWlucykgPyBmdW5jdGlvbihjb250ZXh0LCBub2RlKXtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuY29udGFpbnMobm9kZSlcclxuXHJcbiAgICB9IDogKHJvb3QuY29tcGFyZURvY3VtZW50UG9zaXRpb24pID8gZnVuY3Rpb24oY29udGV4dCwgbm9kZSl7XHJcblxyXG4gICAgICAgIHJldHVybiBjb250ZXh0ID09PSBub2RlIHx8ICEhKGNvbnRleHQuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiAxNilcclxuXHJcbiAgICB9IDogZnVuY3Rpb24oY29udGV4dCwgbm9kZSl7XHJcblxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT09IGNvbnRleHQpIHJldHVybiB0cnVlXHJcbiAgICAgICAgfSB3aGlsZSAoKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICAvLyBzb3J0XHJcbiAgICAvLyBjcmVkaXRzIHRvIFNpenpsZSAoaHR0cDovL3NpenpsZWpzLmNvbS8pXHJcblxyXG4gICAgdGhpcy5zb3J0ZXIgPSAocm9vdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikgPyBmdW5jdGlvbihhLCBiKXtcclxuXHJcbiAgICAgICAgaWYgKCFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIHx8ICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSByZXR1cm4gMFxyXG4gICAgICAgIHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgNCA/IC0xIDogYSA9PT0gYiA/IDAgOiAxXHJcblxyXG4gICAgfSA6ICgnc291cmNlSW5kZXgnIGluIHJvb3QpID8gZnVuY3Rpb24oYSwgYil7XHJcblxyXG4gICAgICAgIGlmICghYS5zb3VyY2VJbmRleCB8fCAhYi5zb3VyY2VJbmRleCkgcmV0dXJuIDBcclxuICAgICAgICByZXR1cm4gYS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXhcclxuXHJcbiAgICB9IDogKGRvY3VtZW50LmNyZWF0ZVJhbmdlKSA/IGZ1bmN0aW9uKGEsIGIpe1xyXG5cclxuICAgICAgICBpZiAoIWEub3duZXJEb2N1bWVudCB8fCAhYi5vd25lckRvY3VtZW50KSByZXR1cm4gMFxyXG4gICAgICAgIHZhciBhUmFuZ2UgPSBhLm93bmVyRG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSxcclxuICAgICAgICAgICAgYlJhbmdlID0gYi5vd25lckRvY3VtZW50LmNyZWF0ZVJhbmdlKClcclxuXHJcbiAgICAgICAgYVJhbmdlLnNldFN0YXJ0KGEsIDApXHJcbiAgICAgICAgYVJhbmdlLnNldEVuZChhLCAwKVxyXG4gICAgICAgIGJSYW5nZS5zZXRTdGFydChiLCAwKVxyXG4gICAgICAgIGJSYW5nZS5zZXRFbmQoYiwgMClcclxuICAgICAgICByZXR1cm4gYVJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhSYW5nZS5TVEFSVF9UT19FTkQsIGJSYW5nZSlcclxuXHJcbiAgICB9IDogbnVsbFxyXG5cclxuICAgIHRoaXMuZmFpbGVkID0ge31cclxuXHJcbiAgICB2YXIgbmF0aXZlTWF0Y2hlcyA9IHRoaXMuaGFzKFwiTUFUQ0hFU19TRUxFQ1RPUlwiKVxyXG5cclxuICAgIGlmIChuYXRpdmVNYXRjaGVzKSB0aGlzLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIGV4cHJlc3Npb24pe1xyXG5cclxuICAgICAgICBpZiAodGhpcy5mYWlsZWRbZXhwcmVzc2lvbl0pIHJldHVybiBudWxsXHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVNYXRjaGVzLmNhbGwobm9kZSwgZXhwcmVzc2lvbilcclxuICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgICBpZiAoc2xpY2suZGVidWcpIGNvbnNvbGUud2FybihcIm1hdGNoZXNTZWxlY3RvciBmYWlsZWQgb24gXCIgKyBleHByZXNzaW9uKVxyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZFtleHByZXNzaW9uXSA9IHRydWVcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmhhcyhcIlFVRVJZX1NFTEVDVE9SXCIpKXtcclxuXHJcbiAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yQWxsID0gZnVuY3Rpb24obm9kZSwgZXhwcmVzc2lvbil7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5mYWlsZWRbZXhwcmVzc2lvbl0pIHJldHVybiB0cnVlXHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBfaWQsIF9leHByZXNzaW9uLCBfY29tYmluYXRvciwgX25vZGVcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBub24tZG9jdW1lbnQgcm9vdGVkIFFTQVxyXG4gICAgICAgICAgICAvLyBjcmVkaXRzIHRvIEFuZHJldyBEdXBvbnRcclxuXHJcbiAgICAgICAgICAgIGlmIChub2RlICE9PSB0aGlzLmRvY3VtZW50KXtcclxuXHJcbiAgICAgICAgICAgICAgICBfY29tYmluYXRvciA9IGV4cHJlc3Npb25bMF0uY29tYmluYXRvclxyXG5cclxuICAgICAgICAgICAgICAgIF9pZCAgICAgICAgID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKVxyXG4gICAgICAgICAgICAgICAgX2V4cHJlc3Npb24gPSBleHByZXNzaW9uXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFfaWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIF9ub2RlID0gbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIF9pZCA9IFwiX19zbGlja19fXCJcclxuICAgICAgICAgICAgICAgICAgICBfbm9kZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBfaWQpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IFwiI1wiICsgX2lkICsgXCIgXCIgKyBfZXhwcmVzc2lvblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBjb21iaW5hdG9ycyBuZWVkIGEgcGFyZW50Tm9kZSBkdWUgdG8gaG93IHF1ZXJ5U2VsZWN0b3JBbGwgd29ya3MsIHdoaWNoIGlzOlxyXG4gICAgICAgICAgICAgICAgLy8gZmluZGluZyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGZpbHRlcmluZyBieSB0aGUgb25lcyB0aGF0IGhhdmUgdGhlIHNwZWNpZmllZCBlbGVtZW50IGFzIGFuIGFuY2VzdG9yXHJcbiAgICAgICAgICAgICAgICBpZiAoX2NvbWJpbmF0b3IuaW5kZXhPZihcIn5cIikgPiAtMSB8fCBfY29tYmluYXRvci5pbmRleE9mKFwiK1wiKSA+IC0xKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZSkgcmVzdWx0ID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vZGUgaGFzIG5vIHBhcmVudE5vZGUsIHdlIHJldHVybiBcInRydWVcIiBhcyBpZiBpdCBmYWlsZWQsIHdpdGhvdXQgcG9sbHV0aW5nIHRoZSBmYWlsZWQgY2FjaGVcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChleHByZXNzaW9uLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2suZGVidWcpIGNvbnNvbGUud2FybihcInF1ZXJ5U2VsZWN0b3JBbGwgZmFpbGVkIG9uIFwiICsgKF9leHByZXNzaW9uIHx8IGV4cHJlc3Npb24pKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5mYWlsZWRbX2V4cHJlc3Npb24gfHwgZXhwcmVzc2lvbl0gPSB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfbm9kZSkgX25vZGUucmVtb3ZlQXR0cmlidXRlKFwiaWRcIilcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbkZpbmRlci5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oRkVBVFVSRSl7XHJcblxyXG4gICAgdmFyIHRlc3RlZCAgICAgICAgPSB0aGlzLnRlc3RlZCxcclxuICAgICAgICB0ZXN0ZWRGRUFUVVJFID0gdGVzdGVkW0ZFQVRVUkVdXHJcblxyXG4gICAgaWYgKHRlc3RlZEZFQVRVUkUgIT0gbnVsbCkgcmV0dXJuIHRlc3RlZEZFQVRVUkVcclxuXHJcbiAgICB2YXIgcm9vdCAgICAgPSB0aGlzLnJvb3QsXHJcbiAgICAgICAgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50LFxyXG4gICAgICAgIHRlc3ROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxyXG5cclxuICAgIHRlc3ROb2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTogbm9uZTtcIilcclxuXHJcbiAgICByb290LmFwcGVuZENoaWxkKHRlc3ROb2RlKVxyXG5cclxuICAgIHZhciBURVNUID0gSEFTW0ZFQVRVUkVdLCByZXN1bHQgPSBmYWxzZVxyXG5cclxuICAgIGlmIChURVNUKSB0cnkge1xyXG4gICAgICAgIHJlc3VsdCA9IFRFU1QuY2FsbChkb2N1bWVudCwgdGVzdE5vZGUpXHJcbiAgICB9IGNhdGNoKGUpe31cclxuXHJcbiAgICBpZiAoc2xpY2suZGVidWcgJiYgIXJlc3VsdCkgY29uc29sZS53YXJuKFwiZG9jdW1lbnQgaGFzIG5vIFwiICsgRkVBVFVSRSlcclxuXHJcbiAgICByb290LnJlbW92ZUNoaWxkKHRlc3ROb2RlKVxyXG5cclxuICAgIHJldHVybiB0ZXN0ZWRbRkVBVFVSRV0gPSByZXN1bHRcclxuXHJcbn1cclxuXHJcbnZhciBjb21iaW5hdG9ycyA9IHtcclxuXHJcbiAgICBcIiBcIjogZnVuY3Rpb24obm9kZSwgcGFydCwgcHVzaCl7XHJcblxyXG4gICAgICAgIHZhciBpdGVtLCBpdGVtc1xyXG5cclxuICAgICAgICB2YXIgbm9JZCA9ICFwYXJ0LmlkLCBub1RhZyA9ICFwYXJ0LnRhZywgbm9DbGFzcyA9ICFwYXJ0LmNsYXNzZXNcclxuXHJcbiAgICAgICAgaWYgKHBhcnQuaWQgJiYgbm9kZS5nZXRFbGVtZW50QnlJZCAmJiB0aGlzLmhhcyhcIkdFVF9FTEVNRU5UX0JZX0lEXCIpKXtcclxuICAgICAgICAgICAgaXRlbSA9IG5vZGUuZ2V0RWxlbWVudEJ5SWQocGFydC5pZClcclxuXHJcbiAgICAgICAgICAgIC8vIHJldHVybiBvbmx5IGlmIGlkIGlzIGZvdW5kLCBlbHNlIGtlZXAgY2hlY2tpbmdcclxuICAgICAgICAgICAgLy8gbWlnaHQgYmUgYSB0YWQgc2xvd2VyIG9uIG5vbi1leGlzdGluZyBpZHMsIGJ1dCBsZXNzIGluc2FuZVxyXG5cclxuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5nZXRBdHRyaWJ1dGUoJ2lkJykgPT09IHBhcnQuaWQpe1xyXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBbaXRlbV1cclxuICAgICAgICAgICAgICAgIG5vSWQgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0YWcgaXMgc3Rhciwgbm8gbmVlZCB0byBjaGVjayBpdCBpbiBtYXRjaCgpXHJcbiAgICAgICAgICAgICAgICBpZiAocGFydC50YWcgPT09IFwiKlwiKSBub1RhZyA9IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpdGVtcyl7XHJcblxyXG4gICAgICAgICAgICBpZiAocGFydC5jbGFzc2VzICYmIG5vZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiB0aGlzLmhhcyhcIkdFVF9FTEVNRU5UU19CWV9DTEFTU19OQU1FXCIpKXtcclxuICAgICAgICAgICAgICAgIGl0ZW1zID0gbm9kZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHBhcnQuY2xhc3NMaXN0KVxyXG4gICAgICAgICAgICAgICAgbm9DbGFzcyA9IHRydWVcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRhZyBpcyBzdGFyLCBubyBuZWVkIHRvIGNoZWNrIGl0IGluIG1hdGNoKClcclxuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCIqXCIpIG5vVGFnID0gdHJ1ZVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHBhcnQudGFnKVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGFnIGlzIHN0YXIsIG5lZWQgdG8gY2hlY2sgaXQgaW4gbWF0Y2ggYmVjYXVzZSBpdCBjb3VsZCBzZWxlY3QganVuaywgYm9ob1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnQudGFnICE9PSBcIipcIikgbm9UYWcgPSB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGl0ZW0gPSBpdGVtc1tpKytdOylcclxuICAgICAgICAgICAgaWYgKChub1RhZyAmJiBub0lkICYmIG5vQ2xhc3MgJiYgIXBhcnQuYXR0cmlidXRlcyAmJiAhcGFydC5wc2V1ZG9zKSB8fCB0aGlzLm1hdGNoKGl0ZW0sIHBhcnQsIG5vVGFnLCBub0lkLCBub0NsYXNzKSlcclxuICAgICAgICAgICAgICAgIHB1c2goaXRlbSlcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIFwiPlwiOiBmdW5jdGlvbihub2RlLCBwYXJ0LCBwdXNoKXsgLy8gZGlyZWN0IGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKChub2RlID0gbm9kZS5maXJzdENoaWxkKSkgZG8ge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIHRoaXMubWF0Y2gobm9kZSwgcGFydCkpIHB1c2gobm9kZSlcclxuICAgICAgICB9IHdoaWxlICgobm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpKVxyXG4gICAgfSxcclxuXHJcbiAgICBcIitcIjogZnVuY3Rpb24obm9kZSwgcGFydCwgcHVzaCl7IC8vIG5leHQgc2libGluZ1xyXG4gICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpKSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKXtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2gobm9kZSwgcGFydCkpIHB1c2gobm9kZSlcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFwiXlwiOiBmdW5jdGlvbihub2RlLCBwYXJ0LCBwdXNoKXsgLy8gZmlyc3QgY2hpbGRcclxuICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkXHJcbiAgICAgICAgaWYgKG5vZGUpe1xyXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSl7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaChub2RlLCBwYXJ0KSkgcHVzaChub2RlKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29tYmluYXRvcnNbJysnXS5jYWxsKHRoaXMsIG5vZGUsIHBhcnQsIHB1c2gpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFwiflwiOiBmdW5jdGlvbihub2RlLCBwYXJ0LCBwdXNoKXsgLy8gbmV4dCBzaWJsaW5nc1xyXG4gICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpKXtcclxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgdGhpcy5tYXRjaChub2RlLCBwYXJ0KSkgcHVzaChub2RlKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgXCIrK1wiOiBmdW5jdGlvbihub2RlLCBwYXJ0LCBwdXNoKXsgLy8gbmV4dCBzaWJsaW5nIGFuZCBwcmV2aW91cyBzaWJsaW5nXHJcbiAgICAgICAgY29tYmluYXRvcnNbJysnXS5jYWxsKHRoaXMsIG5vZGUsIHBhcnQsIHB1c2gpXHJcbiAgICAgICAgY29tYmluYXRvcnNbJyErJ10uY2FsbCh0aGlzLCBub2RlLCBwYXJ0LCBwdXNoKVxyXG4gICAgfSxcclxuXHJcbiAgICBcIn5+XCI6IGZ1bmN0aW9uKG5vZGUsIHBhcnQsIHB1c2gpeyAvLyBuZXh0IHNpYmxpbmdzIGFuZCBwcmV2aW91cyBzaWJsaW5nc1xyXG4gICAgICAgIGNvbWJpbmF0b3JzWyd+J10uY2FsbCh0aGlzLCBub2RlLCBwYXJ0LCBwdXNoKVxyXG4gICAgICAgIGNvbWJpbmF0b3JzWychfiddLmNhbGwodGhpcywgbm9kZSwgcGFydCwgcHVzaClcclxuICAgIH0sXHJcblxyXG4gICAgXCIhXCI6IGZ1bmN0aW9uKG5vZGUsIHBhcnQsIHB1c2gpeyAvLyBhbGwgcGFyZW50IG5vZGVzIHVwIHRvIGRvY3VtZW50XHJcbiAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgaWYgKG5vZGUgIT09IHRoaXMuZG9jdW1lbnQgJiYgdGhpcy5tYXRjaChub2RlLCBwYXJ0KSkgcHVzaChub2RlKVxyXG4gICAgfSxcclxuXHJcbiAgICBcIiE+XCI6IGZ1bmN0aW9uKG5vZGUsIHBhcnQsIHB1c2gpeyAvLyBkaXJlY3QgcGFyZW50IChvbmUgbGV2ZWwpXHJcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZVxyXG4gICAgICAgIGlmIChub2RlICE9PSB0aGlzLmRvY3VtZW50ICYmIHRoaXMubWF0Y2gobm9kZSwgcGFydCkpIHB1c2gobm9kZSlcclxuICAgIH0sXHJcblxyXG4gICAgXCIhK1wiOiBmdW5jdGlvbihub2RlLCBwYXJ0LCBwdXNoKXsgLy8gcHJldmlvdXMgc2libGluZ1xyXG4gICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSkgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKG5vZGUsIHBhcnQpKSBwdXNoKG5vZGUpXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBcIiFeXCI6IGZ1bmN0aW9uKG5vZGUsIHBhcnQsIHB1c2gpeyAvLyBsYXN0IGNoaWxkXHJcbiAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkXHJcbiAgICAgICAgaWYgKG5vZGUpe1xyXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKXtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKG5vZGUsIHBhcnQpKSBwdXNoKG5vZGUpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb21iaW5hdG9yc1snISsnXS5jYWxsKHRoaXMsIG5vZGUsIHBhcnQsIHB1c2gpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFwiIX5cIjogZnVuY3Rpb24obm9kZSwgcGFydCwgcHVzaCl7IC8vIHByZXZpb3VzIHNpYmxpbmdzXHJcbiAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpKXtcclxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgdGhpcy5tYXRjaChub2RlLCBwYXJ0KSkgcHVzaChub2RlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbkZpbmRlci5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24oY29udGV4dCwgZXhwcmVzc2lvbiwgZm91bmQpe1xyXG5cclxuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IHRoaXMuZG9jdW1lbnRcclxuICAgIGVsc2UgaWYgKCFjb250ZXh0Lm5vZGVUeXBlICYmIGNvbnRleHQuZG9jdW1lbnQpIGNvbnRleHQgPSBjb250ZXh0LmRvY3VtZW50XHJcblxyXG4gICAgdmFyIGV4cHJlc3Npb25zID0gcGFyc2UoZXhwcmVzc2lvbilcclxuXHJcbiAgICAvLyBubyBleHByZXNzaW9ucyB3ZXJlIHBhcnNlZC4gdG9kbzogaXMgdGhpcyByZWFsbHkgbmVjZXNzYXJ5P1xyXG4gICAgaWYgKCFleHByZXNzaW9ucyB8fCAhZXhwcmVzc2lvbnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGV4cHJlc3Npb25cIilcclxuXHJcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IFtdXHJcblxyXG4gICAgdmFyIHVuaXF1ZXMsIHB1c2ggPSBpc0FycmF5KGZvdW5kKSA/IGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICAgIGZvdW5kW2ZvdW5kLmxlbmd0aF0gPSBub2RlXHJcbiAgICB9IDogZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgICAgZm91bmRbZm91bmQubGVuZ3RoKytdID0gbm9kZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgZXhwcmVzc2lvbiB3ZSBuZWVkIHRvIGNoZWNrIGZvciBkdXBsaWNhdGVzIHdoZW4gd2UgcHVzaCB0byBmb3VuZFxyXG4gICAgLy8gdGhpcyBzaW1wbHkgc2F2ZXMgdGhlIG9sZCBwdXNoIGFuZCB3cmFwcyBpdCBhcm91bmQgYW4gdWlkIGR1cGUgY2hlY2suXHJcbiAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMSl7XHJcbiAgICAgICAgdW5pcXVlcyA9IHt9XHJcbiAgICAgICAgdmFyIHBsdXNoID0gcHVzaFxyXG4gICAgICAgIHB1c2ggPSBmdW5jdGlvbihub2RlKXtcclxuICAgICAgICAgICAgdmFyIHVpZCA9IHVuaXF1ZUlEKG5vZGUpXHJcbiAgICAgICAgICAgIGlmICghdW5pcXVlc1t1aWRdKXtcclxuICAgICAgICAgICAgICAgIHVuaXF1ZXNbdWlkXSA9IHRydWVcclxuICAgICAgICAgICAgICAgIHBsdXNoKG5vZGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2Fsa2VyXHJcblxyXG4gICAgdmFyIG5vZGUsIG5vZGVzLCBwYXJ0XHJcblxyXG4gICAgbWFpbjogZm9yICh2YXIgaSA9IDA7IGV4cHJlc3Npb24gPSBleHByZXNzaW9uc1tpKytdOyl7XHJcblxyXG4gICAgICAgIC8vIHF1ZXJ5U2VsZWN0b3JcclxuXHJcbiAgICAgICAgLy8gVE9ETzogbW9yZSBmdW5jdGlvbmFsIHRlc3RzXHJcblxyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIHF1ZXJ5U2VsZWN0b3JBbGwgKGFuZCB0aGUgZXhwcmVzc2lvbiBkb2VzIG5vdCBmYWlsKSB1c2UgaXQuXHJcbiAgICAgICAgaWYgKCFzbGljay5ub1FTQSAmJiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwpe1xyXG5cclxuICAgICAgICAgICAgbm9kZXMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoY29udGV4dCwgZXhwcmVzc2lvbilcclxuICAgICAgICAgICAgaWYgKG5vZGVzICE9PSB0cnVlKXtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlcyAmJiBub2Rlcy5sZW5ndGgpIGZvciAodmFyIGogPSAwOyBub2RlID0gbm9kZXNbaisrXTspIGlmIChub2RlLm5vZGVOYW1lID4gJ0AnKXtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoKG5vZGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZSBtYWluXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIHBhcnQgaW4gdGhlIGV4cHJlc3Npb24gd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBlYWNoIHBhcnQgZm9yIGR1cGxpY2F0ZXMuXHJcbiAgICAgICAgLy8gdG9kbzogdGhpcyBtaWdodCBiZSB0b28gbmFpdmUuIHdoaWxlIHNvbGlkLCB0aGVyZSBjYW4gYmUgZXhwcmVzc2lvbiBzZXF1ZW5jZXMgdGhhdCBkbyBub3RcclxuICAgICAgICAvLyBwcm9kdWNlIGR1cGxpY2F0ZXMuIFwiYm9keSBkaXZcIiBmb3IgaW5zdGFuY2UsIGNhbiBuZXZlciBnaXZlIHlvdSBlYWNoIGRpdiBtb3JlIHRoYW4gb25jZS5cclxuICAgICAgICAvLyBcImJvZHkgZGl2IGFcIiBvbiB0aGUgb3RoZXIgaGFuZCBtaWdodC5cclxuICAgICAgICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEpe1xyXG5cclxuICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb25bMF1cclxuICAgICAgICAgICAgY29tYmluYXRvcnNbcGFydC5jb21iaW5hdG9yXS5jYWxsKHRoaXMsIGNvbnRleHQsIHBhcnQsIHB1c2gpXHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY3MgPSBbY29udGV4dF0sIGMsIGYsIHUsIHAgPSBmdW5jdGlvbihub2RlKXtcclxuICAgICAgICAgICAgICAgIHZhciB1aWQgPSB1bmlxdWVJRChub2RlKVxyXG4gICAgICAgICAgICAgICAgaWYgKCF1W3VpZF0pe1xyXG4gICAgICAgICAgICAgICAgICAgIHVbdWlkXSA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICBmW2YubGVuZ3RoXSA9IG5vZGVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gbG9vcCB0aGUgZXhwcmVzc2lvbiBwYXJ0c1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgcGFydCA9IGV4cHJlc3Npb25baisrXTspe1xyXG4gICAgICAgICAgICAgICAgZiA9IFtdOyB1ID0ge31cclxuICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhlIGNvbnRleHRzXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgYyA9IGNzW2srK107KSBjb21iaW5hdG9yc1twYXJ0LmNvbWJpbmF0b3JdLmNhbGwodGhpcywgYywgcGFydCwgcClcclxuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgd2FzIGZvdW5kLCB0aGUgZXhwcmVzc2lvbiBmYWlsZWQsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IGV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAgICBpZiAoIWYubGVuZ3RoKSBjb250aW51ZSBtYWluXHJcbiAgICAgICAgICAgICAgICBjcyA9IGYgLy8gc2V0IHRoZSBjb250ZXh0cyBmb3IgZnV0dXJlIHBhcnRzIChpZiBhbnkpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSBmb3VuZCA9IGYgLy8gZmlyc3QgZXhwcmVzc2lvbi4gZGlyZWN0bHkgc2V0IGZvdW5kLlxyXG4gICAgICAgICAgICBlbHNlIGZvciAodmFyIGwgPSAwOyBsIDwgZi5sZW5ndGg7IGwrKykgcHVzaChmW2xdKSAvLyBhbnkgb3RoZXIgZXhwcmVzc2lvbiBuZWVkcyB0byBwdXNoIHRvIGZvdW5kLlxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVuaXF1ZXMgJiYgZm91bmQgJiYgZm91bmQubGVuZ3RoID4gMSkgdGhpcy5zb3J0KGZvdW5kKVxyXG5cclxuICAgIHJldHVybiBmb3VuZFxyXG5cclxufVxyXG5cclxuRmluZGVyLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24obm9kZXMpe1xyXG4gICAgcmV0dXJuIHRoaXMuc29ydGVyID8gQXJyYXkucHJvdG90eXBlLnNvcnQuY2FsbChub2RlcywgdGhpcy5zb3J0ZXIpIDogbm9kZXNcclxufVxyXG5cclxuLy8gVE9ETzogbW9zdCBvZiB0aGVzZSBwc2V1ZG8gc2VsZWN0b3JzIGluY2x1ZGUgPGh0bWw+IGFuZCBxc2EgZG9lc250LiBmaXhtZS5cclxuXHJcbnZhciBwc2V1ZG9zID0ge1xyXG5cclxuXHJcbiAgICAvLyBUT0RPOiByZXR1cm5zIGRpZmZlcmVudCByZXN1bHRzIHRoYW4gcXNhIGVtcHR5LlxyXG5cclxuICAgICdlbXB0eSc6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuICEodGhpcyAmJiB0aGlzLm5vZGVUeXBlID09PSAxKSAmJiAhKHRoaXMuaW5uZXJUZXh0IHx8IHRoaXMudGV4dENvbnRlbnQgfHwgJycpLmxlbmd0aFxyXG4gICAgfSxcclxuXHJcbiAgICAnbm90JzogZnVuY3Rpb24oZXhwcmVzc2lvbil7XHJcbiAgICAgICAgcmV0dXJuICFzbGljay5tYXRjaGVzKHRoaXMsIGV4cHJlc3Npb24pXHJcbiAgICB9LFxyXG5cclxuICAgICdjb250YWlucyc6IGZ1bmN0aW9uKHRleHQpe1xyXG4gICAgICAgIHJldHVybiAodGhpcy5pbm5lclRleHQgfHwgdGhpcy50ZXh0Q29udGVudCB8fCAnJykuaW5kZXhPZih0ZXh0KSA+IC0xXHJcbiAgICB9LFxyXG5cclxuICAgICdmaXJzdC1jaGlsZCc6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzXHJcbiAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpKSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSByZXR1cm4gZmFsc2VcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICAnbGFzdC1jaGlsZCc6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzXHJcbiAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5uZXh0U2libGluZykpIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9LFxyXG5cclxuICAgICdvbmx5LWNoaWxkJzogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgcHJldiA9IHRoaXNcclxuICAgICAgICB3aGlsZSAoKHByZXYgPSBwcmV2LnByZXZpb3VzU2libGluZykpIGlmIChwcmV2Lm5vZGVUeXBlID09IDEpIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgICB2YXIgbmV4dCA9IHRoaXNcclxuICAgICAgICB3aGlsZSAoKG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nKSkgaWYgKG5leHQubm9kZVR5cGUgPT0gMSkgcmV0dXJuIGZhbHNlXHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9LFxyXG5cclxuICAgICdmaXJzdC1vZi10eXBlJzogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZVxyXG4gICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSkgaWYgKG5vZGUubm9kZU5hbWUgPT0gbm9kZU5hbWUpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9LFxyXG5cclxuICAgICdsYXN0LW9mLXR5cGUnOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcywgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lXHJcbiAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5uZXh0U2libGluZykpIGlmIChub2RlLm5vZGVOYW1lID09IG5vZGVOYW1lKSByZXR1cm4gZmFsc2VcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICAnb25seS1vZi10eXBlJzogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgcHJldiA9IHRoaXMsIG5vZGVOYW1lID0gdGhpcy5ub2RlTmFtZVxyXG4gICAgICAgIHdoaWxlICgocHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nKSkgaWYgKHByZXYubm9kZU5hbWUgPT0gbm9kZU5hbWUpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIHZhciBuZXh0ID0gdGhpc1xyXG4gICAgICAgIHdoaWxlICgobmV4dCA9IG5leHQubmV4dFNpYmxpbmcpKSBpZiAobmV4dC5ub2RlTmFtZSA9PSBub2RlTmFtZSkgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0sXHJcblxyXG4gICAgJ2VuYWJsZWQnOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZFxyXG4gICAgfSxcclxuXHJcbiAgICAnZGlzYWJsZWQnOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkXHJcbiAgICB9LFxyXG5cclxuICAgICdjaGVja2VkJzogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGVja2VkIHx8IHRoaXMuc2VsZWN0ZWRcclxuICAgIH0sXHJcblxyXG4gICAgJ3NlbGVjdGVkJzogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZFxyXG4gICAgfSxcclxuXHJcbiAgICAnZm9jdXMnOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnRcclxuICAgICAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMgJiYgKHRoaXMuaHJlZiB8fCB0aGlzLnR5cGUgfHwgc2xpY2suaGFzQXR0cmlidXRlKHRoaXMsICd0YWJpbmRleCcpKVxyXG4gICAgfSxcclxuXHJcbiAgICAncm9vdCc6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzID09PSB0aGlzLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuRmluZGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKG5vZGUsIGJpdCwgbm9UYWcsIG5vSWQsIG5vQ2xhc3Mpe1xyXG5cclxuICAgIC8vIFRPRE86IG1vcmUgZnVuY3Rpb25hbCB0ZXN0cyA/XHJcblxyXG4gICAgaWYgKCFzbGljay5ub1FTQSAmJiB0aGlzLm1hdGNoZXNTZWxlY3Rvcil7XHJcbiAgICAgICAgdmFyIG1hdGNoZXMgPSB0aGlzLm1hdGNoZXNTZWxlY3Rvcihub2RlLCBiaXQpXHJcbiAgICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHJldHVybiBtYXRjaGVzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gbm9ybWFsIG1hdGNoaW5nXHJcblxyXG4gICAgaWYgKCFub1RhZyAmJiBiaXQudGFnKXtcclxuXHJcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgaWYgKGJpdC50YWcgPT09IFwiKlwiKXtcclxuICAgICAgICAgICAgaWYgKG5vZGVOYW1lIDwgXCJAXCIpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZU5hbWUgIT0gYml0LnRhZyl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFub0lkICYmIGJpdC5pZCAmJiBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSAhPT0gYml0LmlkKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICB2YXIgaSwgcGFydFxyXG5cclxuICAgIGlmICghbm9DbGFzcyAmJiBiaXQuY2xhc3Nlcyl7XHJcblxyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShub2RlLCBcImNsYXNzXCIpXHJcbiAgICAgICAgaWYgKCFjbGFzc05hbWUpIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgICBmb3IgKHBhcnQgaW4gYml0LmNsYXNzZXMpIGlmICghUmVnRXhwKCcoXnxcXFxccyknICsgYml0LmNsYXNzZXNbcGFydF0gKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpKSByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmFtZSwgdmFsdWVcclxuXHJcbiAgICBpZiAoYml0LmF0dHJpYnV0ZXMpIGZvciAoaSA9IDA7IHBhcnQgPSBiaXQuYXR0cmlidXRlc1tpKytdOyl7XHJcblxyXG4gICAgICAgIHZhciBvcGVyYXRvciAgPSBwYXJ0Lm9wZXJhdG9yLFxyXG4gICAgICAgICAgICBlc2NhcGVkICAgPSBwYXJ0LmVzY2FwZWRWYWx1ZVxyXG5cclxuICAgICAgICBuYW1lICA9IHBhcnQubmFtZVxyXG4gICAgICAgIHZhbHVlID0gcGFydC52YWx1ZVxyXG5cclxuICAgICAgICBpZiAoIW9wZXJhdG9yKXtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUobm9kZSwgbmFtZSkpIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdmFyIGFjdHVhbCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUpXHJcbiAgICAgICAgICAgIGlmIChhY3R1YWwgPT0gbnVsbCkgcmV0dXJuIGZhbHNlXHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ149JyA6IGlmICghUmVnRXhwKCAgICAgICdeJyArIGVzY2FwZWQgICAgICAgICAgICApLnRlc3QoYWN0dWFsKSkgcmV0dXJuIGZhbHNlOyBicmVha1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnJD0nIDogaWYgKCFSZWdFeHAoICAgICAgICAgICAgZXNjYXBlZCArICckJyAgICAgICkudGVzdChhY3R1YWwpKSByZXR1cm4gZmFsc2U7IGJyZWFrXHJcbiAgICAgICAgICAgICAgICBjYXNlICd+PScgOiBpZiAoIVJlZ0V4cCgnKF58XFxcXHMpJyArIGVzY2FwZWQgKyAnKFxcXFxzfCQpJykudGVzdChhY3R1YWwpKSByZXR1cm4gZmFsc2U7IGJyZWFrXHJcbiAgICAgICAgICAgICAgICBjYXNlICd8PScgOiBpZiAoIVJlZ0V4cCggICAgICAnXicgKyBlc2NhcGVkICsgJygtfCQpJyAgKS50ZXN0KGFjdHVhbCkpIHJldHVybiBmYWxzZTsgYnJlYWtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICc9JyAgOiBpZiAoYWN0dWFsICE9PSB2YWx1ZSkgcmV0dXJuIGZhbHNlOyBicmVha1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnKj0nIDogaWYgKGFjdHVhbC5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHJldHVybiBmYWxzZTsgYnJlYWtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQgICA6IHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoYml0LnBzZXVkb3MpIGZvciAoaSA9IDA7IHBhcnQgPSBiaXQucHNldWRvc1tpKytdOyl7XHJcblxyXG4gICAgICAgIG5hbWUgID0gcGFydC5uYW1lXHJcbiAgICAgICAgdmFsdWUgPSBwYXJ0LnZhbHVlXHJcblxyXG4gICAgICAgIGlmIChwc2V1ZG9zW25hbWVdKSByZXR1cm4gcHNldWRvc1tuYW1lXS5jYWxsKG5vZGUsIHZhbHVlKVxyXG5cclxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZShub2RlLCBuYW1lKSAhPT0gdmFsdWUpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUobm9kZSwgbmFtZSkpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWVcclxuXHJcbn1cclxuXHJcbkZpbmRlci5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uKG5vZGUsIGV4cHJlc3Npb24pe1xyXG5cclxuICAgIHZhciBleHByZXNzaW9ucyA9IHBhcnNlKGV4cHJlc3Npb24pXHJcblxyXG4gICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSAmJiBleHByZXNzaW9uc1swXS5sZW5ndGggPT09IDEpeyAvLyBzaW1wbGVzdCBtYXRjaFxyXG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoKG5vZGUsIGV4cHJlc3Npb25zWzBdWzBdKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IG1vcmUgZnVuY3Rpb25hbCB0ZXN0cyA/XHJcblxyXG4gICAgaWYgKCFzbGljay5ub1FTQSAmJiB0aGlzLm1hdGNoZXNTZWxlY3Rvcil7XHJcbiAgICAgICAgdmFyIG1hdGNoZXMgPSB0aGlzLm1hdGNoZXNTZWxlY3Rvcihub2RlLCBleHByZXNzaW9ucylcclxuICAgICAgICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkgcmV0dXJuIG1hdGNoZXNcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbm9kZXMgPSB0aGlzLnNlYXJjaCh0aGlzLmRvY3VtZW50LCBleHByZXNzaW9uLCB7bGVuZ3RoOiAwfSlcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgcmVzOyByZXMgPSBub2Rlc1tpKytdOykgaWYgKG5vZGUgPT09IHJlcykgcmV0dXJuIHRydWVcclxuICAgIHJldHVybiBmYWxzZVxyXG5cclxufVxyXG5cclxudmFyIGZpbmRlcnMgPSB7fVxyXG5cclxudmFyIGZpbmRlciA9IGZ1bmN0aW9uKGNvbnRleHQpe1xyXG4gICAgdmFyIGRvYyA9IGNvbnRleHQgfHwgZG9jdW1lbnRcclxuICAgIGlmIChkb2Mub3duZXJEb2N1bWVudCkgZG9jID0gZG9jLm93bmVyRG9jdW1lbnRcclxuICAgIGVsc2UgaWYgKGRvYy5kb2N1bWVudCkgZG9jID0gZG9jLmRvY3VtZW50XHJcblxyXG4gICAgaWYgKGRvYy5ub2RlVHlwZSAhPT0gOSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgZG9jdW1lbnRcIilcclxuXHJcbiAgICB2YXIgdWlkID0gdW5pcXVlSUQoZG9jKVxyXG4gICAgcmV0dXJuIGZpbmRlcnNbdWlkXSB8fCAoZmluZGVyc1t1aWRdID0gbmV3IEZpbmRlcihkb2MpKVxyXG59XHJcblxyXG4vLyAuLi4gQVBJIC4uLlxyXG5cclxudmFyIHNsaWNrID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgY29udGV4dCl7XHJcbiAgICByZXR1cm4gc2xpY2suc2VhcmNoKGV4cHJlc3Npb24sIGNvbnRleHQpXHJcbn1cclxuXHJcbnNsaWNrLnNlYXJjaCA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIGNvbnRleHQsIGZvdW5kKXtcclxuICAgIHJldHVybiBmaW5kZXIoY29udGV4dCkuc2VhcmNoKGNvbnRleHQsIGV4cHJlc3Npb24sIGZvdW5kKVxyXG59XHJcblxyXG5zbGljay5maW5kID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgY29udGV4dCl7XHJcbiAgICByZXR1cm4gZmluZGVyKGNvbnRleHQpLnNlYXJjaChjb250ZXh0LCBleHByZXNzaW9uKVswXSB8fCBudWxsXHJcbn1cclxuXHJcbnNsaWNrLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5vZGUsIG5hbWUpe1xyXG4gICAgcmV0dXJuIGZpbmRlcihub2RlKS5nZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSlcclxufVxyXG5cclxuc2xpY2suaGFzQXR0cmlidXRlID0gZnVuY3Rpb24obm9kZSwgbmFtZSl7XHJcbiAgICByZXR1cm4gZmluZGVyKG5vZGUpLmhhc0F0dHJpYnV0ZShub2RlLCBuYW1lKVxyXG59XHJcblxyXG5zbGljay5jb250YWlucyA9IGZ1bmN0aW9uKGNvbnRleHQsIG5vZGUpe1xyXG4gICAgcmV0dXJuIGZpbmRlcihjb250ZXh0KS5jb250YWlucyhjb250ZXh0LCBub2RlKVxyXG59XHJcblxyXG5zbGljay5tYXRjaGVzID0gZnVuY3Rpb24obm9kZSwgZXhwcmVzc2lvbil7XHJcbiAgICByZXR1cm4gZmluZGVyKG5vZGUpLm1hdGNoZXMobm9kZSwgZXhwcmVzc2lvbilcclxufVxyXG5cclxuc2xpY2suc29ydCA9IGZ1bmN0aW9uKG5vZGVzKXtcclxuICAgIGlmIChub2RlcyAmJiBub2Rlcy5sZW5ndGggPiAxKSBmaW5kZXIobm9kZXNbMF0pLnNvcnQobm9kZXMpXHJcbiAgICByZXR1cm4gbm9kZXNcclxufVxyXG5cclxuc2xpY2sucGFyc2UgPSBwYXJzZTtcclxuXHJcbi8vIHNsaWNrLmRlYnVnID0gdHJ1ZVxyXG4vLyBzbGljay5ub1FTQSAgPSB0cnVlXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHNsaWNrXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvc2xpY2svZmluZGVyLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBeEhBO0FBQ0E7QUEwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkhBO0FBQ0E7QUF5SEE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5GQTtBQUNBO0FBcUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ })
/******/ ]);